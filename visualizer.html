<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç World Simulation Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a1a;
            color: #eee;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            min-width: 250px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #stats h2 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 20px;
            font-weight: 600;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 12px 0;
            font-size: 14px;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
        }
        
        #connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }
        
        .connected {
            background: rgba(76, 175, 80, 0.9);
            border: 2px solid #4caf50;
        }
        
        .disconnected {
            background: rgba(244, 67, 54, 0.9);
            border: 2px solid #f44336;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #controls button {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            border: none;
            color: #fff;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.3);
        }
        
        #controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.5);
        }
        
        #controls button:active {
            transform: translateY(0);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            color: #4ecdc4;
            text-align: center;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(78, 205, 196, 0.2);
            border-top-color: #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            font-size: 12px;
            color: #aaa;
            max-width: 200px;
        }
        
        #legend {
            position: absolute;
            top: 200px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 200px;
        }
        
        #legend h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 16px;
            font-weight: 600;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            font-size: 13px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .legend-label {
            color: #ddd;
            flex: 1;
        }
        
        .legend-count {
            color: #4ecdc4;
            font-weight: bold;
            margin-left: 10px;
        }
        
        #faction-stats {
            position: absolute;
            top: 430px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 250px;
        }
        
        #faction-stats h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 16px;
            font-weight: 600;
        }
        
        .faction-item {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }
        
        .faction-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .faction-count {
            font-size: 12px;
            color: #aaa;
        }
        
        #resource-stats {
            position: absolute;
            top: 620px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 250px;
        }
        
        #resource-stats h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 16px;
            font-weight: 600;
        }
        
        .resource-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 13px;
        }
        
        .resource-icon {
            margin-right: 8px;
        }
        
        #activity-feed {
            position: absolute;
            bottom: 120px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            max-width: 300px;
            max-height: 250px;
            overflow-y: auto;
        }
        
        #activity-feed h3 {
            margin-bottom: 10px;
            color: #4ecdc4;
            font-size: 14px;
            font-weight: 600;
        }
        
        .activity-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 11px;
            color: #ccc;
            border-left: 3px solid #4ecdc4;
        }
        
        .activity-time {
            color: #888;
            font-size: 10px;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            pointer-events: none;
            display: none;
            z-index: 2000;
            border: 2px solid #4ecdc4;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
            max-width: 300px;
        }
        
        #tooltip h4 {
            margin-bottom: 10px;
            color: #4ecdc4;
            font-size: 16px;
        }
        
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .tooltip-label {
            color: #aaa;
        }
        
        .tooltip-value {
            color: #fff;
            font-weight: bold;
        }
        
        .notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            border-left: 4px solid #4ecdc4;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease, slideOut 0.3s ease 2.7s;
            z-index: 1000;
            max-width: 300px;
        }
        
        .notification-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .notification-body {
            font-size: 12px;
            color: #ccc;
        }
        
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }
        
        /* Economy Dashboard */
        #economy-dashboard {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 1400px;
            height: 85%;
            background: linear-gradient(135deg, rgba(10, 10, 26, 0.98), rgba(20, 20, 40, 0.98));
            border: 3px solid #4ecdc4;
            border-radius: 16px;
            box-shadow: 0 16px 64px rgba(0, 0, 0, 0.9);
            z-index: 2000;
            padding: 30px;
            overflow-y: auto;
        }
        
        #economy-dashboard.visible {
            display: block;
        }
        
        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #4ecdc4;
        }
        
        .dashboard-title {
            font-size: 32px;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .dashboard-close {
            font-size: 28px;
            cursor: pointer;
            color: #e74c3c;
            padding: 5px 15px;
            background: rgba(231, 76, 60, 0.2);
            border-radius: 8px;
        }
        
        .dashboard-close:hover {
            background: rgba(231, 76, 60, 0.4);
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .dashboard-card {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(78, 205, 196, 0.3);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
        }
        
        .dashboard-card h3 {
            margin: 0 0 15px 0;
            color: #4ecdc4;
            font-size: 18px;
            border-bottom: 1px solid rgba(78, 205, 196, 0.3);
            padding-bottom: 10px;
        }
        
        .dashboard-metric {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .dashboard-metric-label {
            color: #aaa;
            font-size: 14px;
        }
        
        .dashboard-metric-value {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
        }
        
        .metric-positive {
            color: #2ecc71;
        }
        
        .metric-negative {
            color: #e74c3c;
        }
        
        .metric-neutral {
            color: #f39c12;
        }
        
        .price-chart {
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .price-bar {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .price-bar-label {
            width: 80px;
            color: #aaa;
            font-size: 13px;
        }
        
        .price-bar-container {
            flex: 1;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .price-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .price-bar-value {
            width: 60px;
            text-align: right;
            color: #fff;
            font-weight: bold;
            font-size: 13px;
        }
        
        .price-bar:hover {
            background: rgba(78, 205, 196, 0.1);
            transform: scale(1.02);
            transition: all 0.2s ease;
        }
        
        /* Trading Chart Modal */
        #trading-chart-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 1200px;
            height: 80%;
            background: linear-gradient(135deg, rgba(5, 5, 15, 0.99), rgba(15, 15, 30, 0.99));
            border: 3px solid #f39c12;
            border-radius: 16px;
            box-shadow: 0 20px 80px rgba(0, 0, 0, 0.95);
            z-index: 3000;
            padding: 30px;
            overflow: hidden;
        }
        
        #trading-chart-modal.visible {
            display: flex;
            flex-direction: column;
        }
        
        .trading-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f39c12;
        }
        
        .trading-title {
            font-size: 28px;
            font-weight: bold;
            color: #f39c12;
        }
        
        .trading-close {
            font-size: 32px;
            cursor: pointer;
            color: #e74c3c;
            padding: 5px 15px;
            background: rgba(231, 76, 60, 0.2);
            border-radius: 8px;
        }
        
        .trading-close:hover {
            background: rgba(231, 76, 60, 0.4);
        }
        
        .trading-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .trading-stat {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .trading-stat-label {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        
        .trading-stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
        }
        
        .trading-chart-container {
            flex: 1;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(243, 156, 18, 0.3);
            border-radius: 12px;
            padding: 20px;
            position: relative;
        }
        
        #price-history-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="stats">
        <h2>üìä Simulation Stats</h2>
        <div class="stat-item">
            <span class="stat-label">üßë Agents:</span>
            <span class="stat-value" id="agent-count">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">‚è±Ô∏è Uptime:</span>
            <span class="stat-value" id="uptime">0s</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">üì° Events:</span>
            <span class="stat-value" id="events">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">üéÆ FPS:</span>
            <span class="stat-value" id="fps">60</span>
        </div>
    </div>
    
    <div id="legend">
        <h3>üé® Agent States</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #4ecdc4;"></div>
            <span class="legend-label">Idle</span>
            <span class="legend-count" id="count-idle">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #95e1d3;"></div>
            <span class="legend-label">Moving</span>
            <span class="legend-count" id="count-moving">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b6b;"></div>
            <span class="legend-label">üî® Working</span>
            <span class="legend-count" id="count-working">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffd93d;"></div>
            <span class="legend-label">üçû Eating</span>
            <span class="legend-count" id="count-eating">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #9b59b6;"></div>
            <span class="legend-label">üí§ Sleeping</span>
            <span class="legend-count" id="count-sleeping">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #e74c3c;"></div>
            <span class="legend-label">‚öîÔ∏è Fighting</span>
            <span class="legend-count" id="count-fighting">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #3498db;"></div>
            <span class="legend-label">üí¨ Talking</span>
            <span class="legend-count" id="count-talking">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f39c12;"></div>
            <span class="legend-label">üëÆ Patrolling</span>
            <span class="legend-count" id="count-patrolling">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #2ecc71;"></div>
            <span class="legend-label">üõ°Ô∏è Following</span>
            <span class="legend-count" id="count-following">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8b4513;"></div>
            <span class="legend-label">üèóÔ∏è Building</span>
            <span class="legend-count" id="count-building">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f1c40f;"></div>
            <span class="legend-label">üí∞ Trading</span>
            <span class="legend-count" id="count-trading">0</span>
        </div>
    </div>
    
    <div id="faction-stats">
        <h3>‚öîÔ∏è Political Status</h3>
        <div class="faction-item">
            <div class="faction-name" style="color: #4ecdc4;">üèõÔ∏è Unified Society</div>
            <div class="faction-count" id="unified-count">100 agents</div>
        </div>
        <div id="faction-a-container" style="display: none;">
            <div class="faction-item">
                <div class="faction-name" style="color: #3498db;">üîµ Faction A</div>
                <div class="faction-count" id="faction-a-count">0 agents</div>
            </div>
        </div>
        <div id="faction-b-container" style="display: none;">
            <div class="faction-item">
                <div class="faction-name" style="color: #e74c3c;">üî¥ Faction B</div>
                <div class="faction-count" id="faction-b-count">0 agents</div>
            </div>
        </div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
            <div class="faction-count">
                <span style="color: #ff6b6b;">üíÄ Total Deaths:</span>
                <span id="casualties" style="color: #fff; font-weight: bold;">0</span>
            </div>
        </div>
    </div>
    
    <div id="resource-stats">
        <h3>üè≠ Resources</h3>
        <div class="resource-row">
            <span><span class="resource-icon">üå≤</span>Trees:</span>
            <span id="resource-tree" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
        <div class="resource-row">
            <span><span class="resource-icon">‚õ∞Ô∏è</span>Rocks:</span>
            <span id="resource-rock" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
        <div class="resource-row">
            <span><span class="resource-icon">üåæ</span>Farms:</span>
            <span id="resource-farm" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
        <div class="resource-row">
            <span><span class="resource-icon">‚öôÔ∏è</span>Iron:</span>
            <span id="resource-iron" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
    </div>
    
    <div id="currency-stats" style="position: absolute; top: 720px; left: 20px; background: rgba(0, 0, 0, 0.85); padding: 20px; border-radius: 12px; min-width: 280px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);">
        <h3>üí∞ Economy</h3>
        <div class="resource-row">
            <span>Money Supply:</span>
            <span id="currency-supply" style="color: #f1c40f; font-weight: bold;">0</span>
        </div>
        <div class="resource-row">
            <span>Inflation Rate:</span>
            <span id="currency-inflation" style="color: #e74c3c; font-weight: bold;">0%</span>
        </div>
        <div class="resource-row">
            <span>Purchasing Power:</span>
            <span id="currency-power" style="color: #2ecc71; font-weight: bold;">100%</span>
        </div>
        <div class="resource-row">
            <span>üí∏ Transactions:</span>
            <span id="currency-transactions" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
    </div>
    
    <div id="activity-feed">
        <h3>üì° Live Activity</h3>
        <div id="activity-list"></div>
    </div>
    
    <div id="tooltip"></div>
    
    <!-- Economy Dashboard Overlay -->
    <div id="economy-dashboard">
        <div class="dashboard-header">
            <div class="dashboard-title">üìä Economy & Market Dashboard</div>
            <div class="dashboard-close" onclick="toggleEconomyDashboard()">‚úï</div>
        </div>
        
        <div class="dashboard-grid">
            <!-- Currency Overview -->
            <div class="dashboard-card">
                <h3>üí∞ Currency System</h3>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Total Supply</span>
                    <span class="dashboard-metric-value" id="dash-money-supply">20,000</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Inflation Rate</span>
                    <span class="dashboard-metric-value metric-negative" id="dash-inflation">0.00%</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Purchasing Power</span>
                    <span class="dashboard-metric-value metric-positive" id="dash-purchasing">100.0%</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Transactions</span>
                    <span class="dashboard-metric-value" id="dash-transactions">0</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Velocity</span>
                    <span class="dashboard-metric-value metric-neutral" id="dash-velocity">0.00</span>
                </div>
            </div>
            
            <!-- Market Overview -->
            <div class="dashboard-card">
                <h3>üè™ Market Activity</h3>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Total Markets</span>
                    <span class="dashboard-metric-value" id="dash-market-count">3</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Total Transactions</span>
                    <span class="dashboard-metric-value" id="dash-market-transactions">0</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Avg Reputation</span>
                    <span class="dashboard-metric-value" id="dash-market-reputation">50.0</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Active Traders</span>
                    <span class="dashboard-metric-value" id="dash-active-traders">0</span>
                </div>
            </div>
            
            <!-- Resource Supply -->
            <div class="dashboard-card">
                <h3>üì¶ Resource Supply</h3>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">üå≤ Wood</span>
                    <span class="dashboard-metric-value metric-positive" id="dash-supply-wood">0</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">ü™® Stone</span>
                    <span class="dashboard-metric-value metric-positive" id="dash-supply-stone">0</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">üåæ Food</span>
                    <span class="dashboard-metric-value metric-positive" id="dash-supply-food">0</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">‚öôÔ∏è Iron</span>
                    <span class="dashboard-metric-value metric-positive" id="dash-supply-iron">0</span>
                </div>
            </div>
        </div>
        
        <!-- Resource Prices Chart (Clickable) -->
        <div class="dashboard-card" style="grid-column: span 3;">
            <h3>üíπ Resource Prices (per unit) - Click for Trading Chart</h3>
            <div class="price-chart">
                <div class="price-bar" style="cursor: pointer;" onclick="openTradingChart('wood', 'üå≤ Wood')">
                    <span class="price-bar-label">üå≤ Wood</span>
                    <div class="price-bar-container">
                        <div class="price-bar-fill" id="price-bar-wood" style="width: 10%;"></div>
                    </div>
                    <span class="price-bar-value" id="price-wood">5.0</span>
                </div>
                <div class="price-bar" style="cursor: pointer;" onclick="openTradingChart('stone', 'ü™® Stone')">
                    <span class="price-bar-label">ü™® Stone</span>
                    <div class="price-bar-container">
                        <div class="price-bar-fill" id="price-bar-stone" style="width: 6%;"></div>
                    </div>
                    <span class="price-bar-value" id="price-stone">3.0</span>
                </div>
                <div class="price-bar" style="cursor: pointer;" onclick="openTradingChart('food', 'üåæ Food')">
                    <span class="price-bar-label">üåæ Food</span>
                    <div class="price-bar-container">
                        <div class="price-bar-fill" id="price-bar-food" style="width: 20%;"></div>
                    </div>
                    <span class="price-bar-value" id="price-food">10.0</span>
                </div>
                <div class="price-bar" style="cursor: pointer;" onclick="openTradingChart('iron', '‚öôÔ∏è Iron')">
                    <span class="price-bar-label">‚öôÔ∏è Iron</span>
                    <div class="price-bar-container">
                        <div class="price-bar-fill" id="price-bar-iron" style="width: 30%;"></div>
                    </div>
                    <span class="price-bar-value" id="price-iron">15.0</span>
                </div>
                <div class="price-bar" style="cursor: pointer;" onclick="openTradingChart('weapon', '‚öîÔ∏è Weapon')">
                    <span class="price-bar-label">‚öîÔ∏è Weapon</span>
                    <div class="price-bar-container">
                        <div class="price-bar-fill" id="price-bar-weapon" style="width: 100%;"></div>
                    </div>
                    <span class="price-bar-value" id="price-weapon">50.0</span>
                </div>
            </div>
        </div>
        
        <!-- Per Capita Resources -->
        <div class="dashboard-grid">
            <div class="dashboard-card">
                <h3>üë• Per Capita Resources</h3>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Food / Person</span>
                    <span class="dashboard-metric-value" id="dash-food-per-capita">0.0</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Materials / Person</span>
                    <span class="dashboard-metric-value" id="dash-materials-per-capita">0.0</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">War Threshold</span>
                    <span class="dashboard-metric-value metric-negative">Food &lt;10, Mat &lt;15</span>
                </div>
            </div>
            
            <!-- Market Details -->
            <div class="dashboard-card">
                <h3>üèõÔ∏è Market Details</h3>
                <div id="market-details-list">
                    <!-- Will be populated dynamically -->
                </div>
            </div>
            
            <!-- Economic Health -->
            <div class="dashboard-card">
                <h3>üìà Economic Health</h3>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Overall Status</span>
                    <span class="dashboard-metric-value metric-positive" id="dash-economic-status">Healthy</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Resource Stress</span>
                    <span class="dashboard-metric-value" id="dash-resource-stress">Low</span>
                </div>
                <div class="dashboard-metric">
                    <span class="dashboard-metric-label">Market Activity</span>
                    <span class="dashboard-metric-value" id="dash-market-activity">Active</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Trading Chart Modal -->
    <div id="trading-chart-modal">
        <div class="trading-header">
            <div class="trading-title" id="trading-chart-title">üìà Resource Trading Chart</div>
            <div class="trading-close" onclick="closeTradingChart()">‚úï</div>
        </div>
        
        <div class="trading-stats">
            <div class="trading-stat">
                <div class="trading-stat-label">Current Price</div>
                <div class="trading-stat-value" id="trading-current-price">5.0</div>
            </div>
            <div class="trading-stat">
                <div class="trading-stat-label">Session High</div>
                <div class="trading-stat-value metric-positive" id="trading-high-price">5.2</div>
            </div>
            <div class="trading-stat">
                <div class="trading-stat-label">Session Low</div>
                <div class="trading-stat-value metric-negative" id="trading-low-price">4.8</div>
            </div>
            <div class="trading-stat">
                <div class="trading-stat-label">Session Change</div>
                <div class="trading-stat-value" id="trading-price-change">+0.0%</div>
            </div>
        </div>
        
        <div class="trading-chart-container">
            <canvas id="price-history-canvas"></canvas>
        </div>
    </div>
    
    <div id="connection-status" class="disconnected">‚óè Connecting...</div>
    
    <div id="controls">
        <button onclick="resetCamera()">üé• Reset Camera</button>
        <button onclick="togglePause()" id="pauseBtn">‚è∏Ô∏è Pause</button>
        <button onclick="testCombat()">‚öîÔ∏è Test Combat</button>
        <button onclick="testBuilding()">üèóÔ∏è Test Building</button>
        <button onclick="toggleEconomyDashboard()">üìä Economy Dashboard</button>
    </div>
    
    <div id="info">
        <strong>üïπÔ∏è Controls:</strong><br>
        Left Mouse: Rotate<br>
        Right Mouse: Pan<br>
        Scroll: Zoom
    </div>
    
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        Loading Three.js...
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        const API_URL = 'http://127.0.0.1:8080';
        let scene, camera, renderer, controls;
        let agents = new Map();
        let resources = new Map();
        let isPaused = false;
        let terrainMesh;
        let lastEventCount = 0;
        let initialAgentCount = 100;
        let activityLog = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isInitialLoad = true;
        let knownAgentIds = new Set();
        let headstones = [];
        let showingFactionColors = false;
        let lastKnownEventId = null;
        let processedEventIds = new Set();
        let markets = new Map();
        let buildings = new Map();
        let priceHistory = {
            wood: [],
            stone: [],
            food: [],
            iron: [],
            weapon: []
        };
        let currentTradingResource = null;
        let priceHistoryInterval = null;
        let backgroundPriceTracking = null;
        const MAX_PRICE_HISTORY = 500; // Store ~16 minutes of data at 2s intervals
        
        // State-based colors
        const STATE_COLORS = {
            'Idle': 0x4ecdc4,      // Cyan
            'Moving': 0x95e1d3,    // Light cyan  
            'Working': 0xff6b6b,   // Red
            'Eating': 0xffd93d,    // Yellow
            'Sleeping': 0x9b59b6,  // Purple
            'Fighting': 0xe74c3c,  // Dark red
            'Dead': 0x555555,      // Gray
            'Talking': 0x3498db,   // Blue
            'Patrolling': 0xf39c12,// Orange
            'Following': 0x2ecc71, // Green
            'Building': 0x8b4513,  // Brown
            'Trading': 0xf1c40f    // Gold
        };
        
        // Social class visual styles
        const CLASS_STYLES = {
            'King': { scale: 1.5, icon: 'üëë', color: 0xffd700 },
            'Noble': { scale: 1.3, icon: 'üé©', color: 0x9b59b6 },
            'Knight': { scale: 1.2, icon: 'üõ°Ô∏è', color: 0x34495e },
            'Soldier': { scale: 1.1, icon: '‚öîÔ∏è', color: 0x7f8c8d },
            'Merchant': { scale: 1.0, icon: 'üí∞', color: 0xf39c12 },
            'Burgher': { scale: 1.0, icon: 'üè™', color: 0xe67e22 },
            'Cleric': { scale: 1.0, icon: '‚úùÔ∏è', color: 0xecf0f1 },
            'Peasant': { scale: 0.9, icon: 'üë®', color: 0x95a5a6 }
        };
        
        // Faction colors (for team identification)
        const FACTION_COLORS = {
            'Kingdom A': 0x3498db,  // Blue team
            'Kingdom B': 0xe74c3c,  // Red team
        };
        
        // Initialize Three.js scene
        function init() {
            document.getElementById('loading').style.display = 'none';
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.Fog(0x0a0a1a, 150, 400);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(70, 60, 70);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 200;
            controls.maxPolarAngle = Math.PI / 2.1;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0x404060, 1.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(80, 120, 60);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // Hemisphere light for ambient atmosphere
            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x6b8e23, 0.5);
            scene.add(hemiLight);
            
            // Grid helper
            const gridHelper = new THREE.GridHelper(200, 40, 0x4ecdc4, 0x2a2a3e);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
            
            // Terrain plane
            const terrainGeometry = new THREE.PlaneGeometry(200, 200, 20, 20);
            const terrainMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a4d2e,
                roughness: 0.9,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            terrainMesh = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrainMesh.rotation.x = -Math.PI / 2;
            terrainMesh.receiveShadow = true;
            terrainMesh.position.y = 0;
            scene.add(terrainMesh);
            
            // Resources will be added dynamically from API
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Handle mouse movement for tooltips
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onClick);
            
            // Add faction UI hover listeners
            const factionStats = document.getElementById('faction-stats');
            if (factionStats) {
                factionStats.addEventListener('mouseenter', showFactionColors);
                factionStats.addEventListener('mouseleave', showStateColors);
            }
            
            // Start animation loop
            animate();
            
            // Start fetching data
            fetchWorldState();
            setInterval(fetchWorldState, 200); // Update every 0.2 seconds for smoother movement (was 500ms)
            fetchMetrics();
            setInterval(fetchMetrics, 1000);
            fetchEvents();
            setInterval(fetchEvents, 3000); // Check for new events every 3 seconds
        }
        
        
        // Fetch world state from API
        async function fetchWorldState() {
            try {
                const response = await fetch(`${API_URL}/api/world/state`);
                if (!response.ok) {
                    throw new Error('API returned ' + response.status);
                }
                const data = await response.json();
                
                // Check if we got valid data
                if (data && data.agents) {
                    updateConnectionStatus(true);
                    updateAgents(data.agents);
                    updateResources(data.resources || []);
                    updateMarkets(data.markets || []);
                    updateBuildings(data.buildings || []);
                    updateCurrencyInfo(data.currency_info || {});
                } else {
                    console.warn('Invalid data received:', data);
                    updateConnectionStatus(false);
                }
            } catch (error) {
                console.error('Error fetching world state:', error);
                updateConnectionStatus(false);
            }
        }
        
        // Fetch metrics from API
        async function fetchMetrics() {
            try {
                const response = await fetch(`${API_URL}/api/metrics`);
                if (!response.ok) throw new Error('API returned ' + response.status);
                const data = await response.json();
                
                document.getElementById('agent-count').textContent = data.agent_count || 0;
                document.getElementById('uptime').textContent = `${data.uptime_seconds || 0}s`;
                document.getElementById('events').textContent = data.events_processed || 0;
                
                // Check for new events
                if (data.events_processed > lastEventCount && lastEventCount > 0) {
                    showNotification('üì° New Event', 'Simulation event occurred');
                    logActivity('üì° Simulation event triggered', 'event');
                }
                lastEventCount = data.events_processed;
            } catch (error) {
                console.error('Error fetching metrics:', error);
            }
        }
        
        // Fetch simulation events
        async function fetchEvents() {
            try {
                const response = await fetch(`${API_URL}/api/events/history?limit=20`);
                if (!response.ok) return;
                
                const data = await response.json();
                const events = data.events || [];
                
                // Process new events (in reverse order, oldest first)
                events.reverse().forEach(event => {
                    // Skip if already processed
                    if (processedEventIds.has(event.id)) return;
                    
                    processedEventIds.add(event.id);
                    displayEvent(event);
                });
                
                // Keep set from growing too large
                if (processedEventIds.size > 100) {
                    const arr = Array.from(processedEventIds);
                    processedEventIds = new Set(arr.slice(-50));
                }
            } catch (error) {
                // Silent fail - events are optional
            }
        }
        
        // Display a simulation event with dramatic flair
        function displayEvent(event) {
            const eventType = event.event_type;
            const payload = event.payload || {};
            
            // Determine event styling based on type
            let icon = 'üì°';
            let title = 'Simulation Event';
            let description = 'Something happened';
            let color = '#4ecdc4';
            let logType = 'event';
            
            switch (eventType) {
                case 'DungeonMaster':
                    icon = 'üé≠';
                    title = payload.event_name || 'Dungeon Master Event';
                    description = payload.description || '';
                    color = '#9b59b6';
                    logType = 'event';
                    
                    // Special handling for specific events
                    if (title.includes('Plague')) {
                        icon = '‚ò†Ô∏è';
                        color = '#e74c3c';
                    } else if (title.includes('Drought')) {
                        icon = 'üåµ';
                        color = '#e67e22';
                    } else if (title.includes('Blight')) {
                        icon = 'üçÇ';
                        color = '#8b4513';
                    } else if (title.includes('Earthquake')) {
                        icon = 'üåç';
                        color = '#7f8c8d';
                    } else if (title.includes('Revolt') || title.includes('Uprising')) {
                        icon = '‚öîÔ∏è';
                        color = '#c0392b';
                    } else if (title.includes('Discovery') || title.includes('Gold')) {
                        icon = '‚ú®';
                        color = '#f1c40f';
                    }
                    break;
                    
                case 'BlightStarted':
                    icon = 'üçÇ';
                    title = 'Blight Outbreak';
                    description = `A blight affects ${payload.affected_resource || 'resources'} in a ${(payload.radius || 0).toFixed(0)}m radius`;
                    color = '#8b4513';
                    logType = 'event';
                    break;
                    
                case 'DroughtStarted':
                    icon = 'üåµ';
                    title = 'Drought Begins';
                    description = `Severe drought in ${payload.region || 'the region'} for ${payload.expected_duration_days || 0} days`;
                    color = '#e67e22';
                    logType = 'event';
                    break;
                    
                case 'WarDeclared':
                    icon = '‚öîÔ∏è';
                    title = 'War Declared!';
                    description = payload.reason || 'Factions go to war';
                    color = '#c0392b';
                    logType = 'combat';
                    break;
                    
                case 'PeaceTreaty':
                    icon = 'üïäÔ∏è';
                    title = 'Peace Treaty';
                    description = payload.terms || 'Factions make peace';
                    color = '#27ae60';
                    logType = 'info';
                    break;
                    
                default:
                    // Generic event
                    description = JSON.stringify(payload).slice(0, 100);
            }
            
            // Show dramatic notification
            showDramaticNotification(icon, title, description, color);
            
            // Log to activity feed
            logActivity(`${icon} ${title}: ${description}`, logType);
        }
        
        // Update connection status indicator
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');
            if (connected) {
                statusEl.textContent = '‚óè Connected';
                statusEl.className = 'connected';
            } else {
                statusEl.textContent = '‚óè Disconnected';
                statusEl.className = 'disconnected';
            }
        }
        
        // Update agents in the scene
        function updateAgents(agentData) {
            const currentAgentIds = new Set();
            
            // Count states and factions
            const stateCounts = {
                'Idle': 0, 'Moving': 0, 'Working': 0,
                'Eating': 0, 'Sleeping': 0, 'Fighting': 0,
                'Talking': 0, 'Patrolling': 0, 'Following': 0,
                'Building': 0, 'Trading': 0
            };
            let factionACount = 0, factionBCount = 0, unifiedCount = 0;
            const uniqueFactions = new Set();
            
            agentData.forEach(agentInfo => {
                currentAgentIds.add(agentInfo.id);
                
                // Count states
                if (stateCounts[agentInfo.state] !== undefined) {
                    stateCounts[agentInfo.state]++;
                }
                
                // Count factions
                if (agentInfo.faction) {
                    uniqueFactions.add(agentInfo.faction);
                    // Simplified: first unique faction = A, second = B
                    const factionArray = Array.from(uniqueFactions);
                    if (factionArray.indexOf(agentInfo.faction) === 0) {
                        factionACount++;
                    } else if (factionArray.indexOf(agentInfo.faction) === 1) {
                        factionBCount++;
                    }
                } else {
                    unifiedCount++;
                }
                
                if (!agents.has(agentInfo.id)) {
                    // Always use state-based color by default
                    const state = agentInfo.state || 'Idle';
                    const color = new THREE.Color(STATE_COLORS[state] || STATE_COLORS['Idle']);
                    
                    // Get social class style
                    const socialClass = agentInfo.social_class || 'Peasant';
                    const classStyle = CLASS_STYLES[socialClass] || CLASS_STYLES['Peasant'];
                    
                    // Create agent as a Group for easier hovering
                    const agentGroup = new THREE.Group();
                    
                    // Agent body (capsule) - size based on social class
                    const scale = classStyle.scale;
                    const geometry = new THREE.CapsuleGeometry(0.5 * scale, 1.5 * scale, 8, 16);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.6,
                        metalness: 0.4,
                        emissive: color,
                        emissiveIntensity: 0.2
                    });
                    const body = new THREE.Mesh(geometry, material);
                    body.castShadow = true;
                    body.receiveShadow = true;
                    agentGroup.add(body);
                    
                    // Add a little glow sphere on top (head indicator)
                    const headGeometry = new THREE.SphereGeometry(0.3 * scale, 8, 8);
                    const headMaterial = new THREE.MeshBasicMaterial({ 
                        color: color,
                        opacity: 0.8,
                        transparent: true
                    });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.y = 1.5 * scale;
                    agentGroup.add(head);
                    
                    // Add social class icon above head
                    const iconCanvas = document.createElement('canvas');
                    iconCanvas.width = 128;
                    iconCanvas.height = 128;
                    const iconCtx = iconCanvas.getContext('2d');
                    iconCtx.font = 'bold 100px Arial';
                    iconCtx.textAlign = 'center';
                    iconCtx.textBaseline = 'middle';
                    iconCtx.fillText(classStyle.icon, 64, 64);
                    
                    const iconTexture = new THREE.CanvasTexture(iconCanvas);
                    const classIconSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: iconTexture,
                        transparent: true,
                        depthTest: false
                    }));
                    classIconSprite.scale.set(1.2 * scale, 1.2 * scale, 1);
                    classIconSprite.position.y = 2.5 * scale;
                    agentGroup.add(classIconSprite);
                    
                    // Add invisible collision box for easier hovering (covers full body + head)
                    const collisionBox = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5 * scale, 3 * scale, 1.5 * scale),
                        new THREE.MeshBasicMaterial({ visible: false })
                    );
                    collisionBox.position.y = 0.75 * scale; // Center of agent
                    agentGroup.add(collisionBox);
                    
                    scene.add(agentGroup);
                    
                    // Only show birth notification if this is a NEW agent (not initial load)
                    if (!isInitialLoad && !knownAgentIds.has(agentInfo.id)) {
                        showNotification('üë∂ Agent Born', agentInfo.name);
                        logActivity(`üë∂ ${agentInfo.name} was born`, 'birth');
                    }
                    
                    knownAgentIds.add(agentInfo.id);
                    
                    agents.set(agentInfo.id, {
                        mesh: agentGroup,
                        body: body,
                        head: head,
                        targetPos: new THREE.Vector3(agentInfo.x, agentInfo.y + 1, agentInfo.z),
                        name: agentInfo.name,
                        state: agentInfo.state || 'Idle',
                        faction: agentInfo.faction,
                        agentData: agentInfo
                    });
                } else {
                    // Update target position and state color
                    const agent = agents.get(agentInfo.id);
                    agent.targetPos.set(agentInfo.x, agentInfo.y + 1, agentInfo.z);
                    
                    // Update state and add visual effects
                    const newState = agentInfo.state || 'Idle';
                    if (agent.state !== newState) {
                        agent.state = newState;
                        
                        // Combat flash effect
                        if (newState === 'Fighting') {
                            agent.body.material.emissiveIntensity = 0.8;
                            
                            // Add red glow for fighting
                            const combatColor = new THREE.Color(0xff0000);
                            agent.body.material.emissive = combatColor;
                            
                            // Add combat visual indicators
                            addCombatIndicators(agent);
                            
                            // Create spark particles
                            createCombatEffect(agent.mesh.position);
                            logActivity(`‚öîÔ∏è ${agent.name} is fighting!`, 'combat');
                        } else if (agent.state === 'Fighting' && newState !== 'Fighting') {
                            // Combat ended
                            removeCombatIndicators(agent);
                            logActivity(`‚úÖ ${agent.name} stopped fighting`, 'info');
                        }
                        
                        // Conversation speech bubble
                        if (newState === 'Talking') {
                            addSpeechBubble(agent);
                        } else if (agent.state === 'Talking' && newState !== 'Talking') {
                            removeSpeechBubble(agent);
                        }
                        
                        if (newState !== 'Fighting') {
                            // Return to normal state color
                            agent.body.material.emissiveIntensity = 0.2;
                            const stateColor = new THREE.Color(STATE_COLORS[newState] || STATE_COLORS['Idle']);
                            agent.body.material.emissive = stateColor;
                            agent.body.material.color = stateColor;
                            agent.head.material.color = stateColor;
                        }
                    }
                    
                    // Store updated data for tooltip
                    agent.agentData = agentInfo;
                }
            });
            
            // Update legend counts
            document.getElementById('count-idle').textContent = stateCounts['Idle'];
            document.getElementById('count-moving').textContent = stateCounts['Moving'];
            document.getElementById('count-working').textContent = stateCounts['Working'];
            document.getElementById('count-eating').textContent = stateCounts['Eating'];
            document.getElementById('count-sleeping').textContent = stateCounts['Sleeping'];
            document.getElementById('count-fighting').textContent = stateCounts['Fighting'];
            document.getElementById('count-talking').textContent = stateCounts['Talking'];
            document.getElementById('count-patrolling').textContent = stateCounts['Patrolling'];
            document.getElementById('count-following').textContent = stateCounts['Following'];
            document.getElementById('count-building').textContent = stateCounts['Building'];
            document.getElementById('count-trading').textContent = stateCounts['Trading'];
            
            // Update faction counts - show/hide based on whether factions exist
            if (uniqueFactions.size === 0) {
                // No factions - unified society
                document.getElementById('unified-count').textContent = `${unifiedCount} agents`;
                document.getElementById('faction-a-container').style.display = 'none';
                document.getElementById('faction-b-container').style.display = 'none';
            } else if (uniqueFactions.size === 1) {
                // One faction formed
                document.getElementById('unified-count').textContent = `${unifiedCount} unaligned`;
                document.getElementById('faction-a-container').style.display = 'block';
                document.getElementById('faction-a-count').textContent = `${factionACount} agents`;
                document.getElementById('faction-b-container').style.display = 'none';
            } else {
                // Multiple factions - hide unified count
                document.getElementById('unified-count').textContent = `${unifiedCount} unaligned`;
                document.getElementById('faction-a-container').style.display = 'block';
                document.getElementById('faction-a-count').textContent = `${factionACount} agents`;
                document.getElementById('faction-b-container').style.display = 'block';
                document.getElementById('faction-b-count').textContent = `${factionBCount} agents`;
            }
            
            // Calculate casualties
            const casualties = initialAgentCount - agentData.length;
            document.getElementById('casualties').textContent = casualties;
            
            // After first update, mark as no longer initial load
            if (isInitialLoad && agentData.length > 0) {
                isInitialLoad = false;
                logActivity('üåç World simulation loaded', 'info');
                logActivity('üèõÔ∏è Unified society - 100 citizens', 'info');
            }
            
            // Remove agents that no longer exist (died)
            agents.forEach((agent, id) => {
                if (!currentAgentIds.has(id)) {
                    // Death animation - dramatic!
                    showNotification('üíÄ Agent Died', agent.name);
                    logActivity(`üíÄ ${agent.name} has died`, 'death');
                    
                    // Remove visual indicators if present
                    removeCombatIndicators(agent);
                    removeSpeechBubble(agent);
                    
                    // Create headstone/grave marker at death location
                    createHeadstone(agent.mesh.position, agent.name);
                    
                    // Explosion effect
                    createDeathEffect(agent.mesh.position);
                    
                    // Fade and shrink
                    const fadeOut = () => {
                        agent.mesh.scale.multiplyScalar(0.95);
                        agent.body.material.opacity -= 0.05;
                        agent.head.material.opacity -= 0.05;
                        if (agent.body.material.opacity > 0) {
                            requestAnimationFrame(fadeOut);
                        } else {
                            scene.remove(agent.mesh);
                        }
                    };
                    agent.body.material.transparent = true;
                    agent.head.material.transparent = true;
                    fadeOut();
                    agents.delete(id);
                }
            });
        }
        
        // Update resources in the scene
        function updateResources(resourceData) {
            const currentResourceIds = new Set();
            
            // Count resource types
            const resourceCounts = { tree: 0, rock: 0, farm: 0, iron: 0 };
            
            resourceData.forEach(resourceInfo => {
                currentResourceIds.add(resourceInfo.id);
                
                // Count resources
                if (resourceCounts[resourceInfo.resource_type] !== undefined) {
                    resourceCounts[resourceInfo.resource_type]++;
                }
                
                if (!resources.has(resourceInfo.id)) {
                    // Create new resource - all resources are now Groups with collision boxes
                    let visualMesh;
                    let containerGroup = new THREE.Group();
                    
                    switch(resourceInfo.resource_type) {
                        case 'tree':
                            // Tree trunk
                            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 5, 8);
                            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x3a2814 });
                            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                            trunk.castShadow = true;
                            
                            // Tree canopy
                            const canopyGeometry = new THREE.SphereGeometry(2, 8, 8);
                            const canopyMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5016 });
                            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                            canopy.position.y = 4;
                            canopy.castShadow = true;
                            
                            containerGroup.add(trunk);
                            containerGroup.add(canopy);
                            
                            // Add invisible collision box for easier hover
                            const treeCollisionBox = new THREE.Mesh(
                                new THREE.BoxGeometry(4, 8, 4),
                                new THREE.MeshBasicMaterial({ visible: false })
                            );
                            treeCollisionBox.position.y = 2.5;
                            containerGroup.add(treeCollisionBox);
                            break;
                            
                        case 'rock':
                            // Rock visual
                            const rockGeometry = new THREE.DodecahedronGeometry(1.5, 0);
                            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
                            visualMesh = new THREE.Mesh(rockGeometry, rockMaterial);
                            visualMesh.castShadow = true;
                            containerGroup.add(visualMesh);
                            
                            // Add larger invisible collision box
                            const rockCollisionBox = new THREE.Mesh(
                                new THREE.BoxGeometry(4, 4, 4),
                                new THREE.MeshBasicMaterial({ visible: false })
                            );
                            rockCollisionBox.position.y = 1;
                            containerGroup.add(rockCollisionBox);
                            break;
                            
                        case 'farm':
                            // Farm plot visual
                            const farmGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                            const farmMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                            visualMesh = new THREE.Mesh(farmGeometry, farmMaterial);
                            visualMesh.receiveShadow = true;
                            containerGroup.add(visualMesh);
                            
                            // Add taller invisible collision box for easier hover
                            const farmCollisionBox = new THREE.Mesh(
                                new THREE.BoxGeometry(4, 3, 4),
                                new THREE.MeshBasicMaterial({ visible: false })
                            );
                            farmCollisionBox.position.y = 1.5;
                            containerGroup.add(farmCollisionBox);
                            break;
                            
                        case 'iron':
                            // Iron deposit visual
                            const ironGeometry = new THREE.OctahedronGeometry(1.2);
                            const ironMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x708090, 
                                metalness: 0.8,
                                roughness: 0.3
                            });
                            visualMesh = new THREE.Mesh(ironGeometry, ironMaterial);
                            visualMesh.castShadow = true;
                            containerGroup.add(visualMesh);
                            
                            // Add larger invisible collision box
                            const ironCollisionBox = new THREE.Mesh(
                                new THREE.BoxGeometry(4, 4, 4),
                                new THREE.MeshBasicMaterial({ visible: false })
                            );
                            ironCollisionBox.position.y = 1;
                            containerGroup.add(ironCollisionBox);
                            break;
                    }
                    
                    containerGroup.position.set(resourceInfo.x, resourceInfo.y, resourceInfo.z);
                    scene.add(containerGroup);
                    
                    resources.set(resourceInfo.id, {
                        mesh: containerGroup,
                        type: resourceInfo.resource_type,
                        data: resourceInfo
                    });
                }
            });
            
            // Remove depleted resources
            resources.forEach((resource, id) => {
                if (!currentResourceIds.has(id)) {
                    scene.remove(resource.mesh);
                    resources.delete(id);
                }
            });
            
            // Update resource counts in UI
            document.getElementById('resource-tree').textContent = resourceCounts.tree;
            document.getElementById('resource-rock').textContent = resourceCounts.rock;
            document.getElementById('resource-farm').textContent = resourceCounts.farm;
            document.getElementById('resource-iron').textContent = resourceCounts.iron;
        }
        
        // Update markets in the scene
        function updateMarkets(marketData) {
            const currentMarketIds = new Set();
            
            marketData.forEach(marketInfo => {
                currentMarketIds.add(marketInfo.id);
                
                if (!markets.has(marketInfo.id)) {
                    // Create new market building
                    const marketGroup = new THREE.Group();
                    
                    // Market building base
                    const baseGeometry = new THREE.BoxGeometry(8, 0.5, 8);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x6a4c3a });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 0.25;
                    marketGroup.add(base);
                    
                    // Market building walls
                    const wallGeometry = new THREE.BoxGeometry(7, 4, 7);
                    const wallMaterial = new THREE.MeshStandardMaterial({ 
                        color: marketInfo.market_type === 'food' ? 0x8b6914 : 0x7a5c4d,
                        roughness: 0.8
                    });
                    const walls = new THREE.Mesh(wallGeometry, wallMaterial);
                    walls.position.y = 2.5;
                    walls.castShadow = true;
                    marketGroup.add(walls);
                    
                    // Market roof
                    const roofGeometry = new THREE.ConeGeometry(5.5, 2, 4);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8b0000 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 5.5;
                    roof.rotation.y = Math.PI / 4;
                    roof.castShadow = true;
                    marketGroup.add(roof);
                    
                    // Market sign/icon above
                    const canvas = document.createElement('canvas');
                    canvas.width = 128;
                    canvas.height = 128;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw market icon based on type
                    let icon = 'üè™';
                    if (marketInfo.market_type === 'food') icon = 'üçû';
                    else if (marketInfo.market_type === 'materials') icon = '‚öíÔ∏è';
                    else if (marketInfo.market_type === 'luxury') icon = 'üíé';
                    else if (marketInfo.market_type === 'weapons') icon = '‚öîÔ∏è';
                    
                    ctx.font = 'bold 80px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(icon, 64, 64);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const signSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: texture,
                        transparent: true
                    }));
                    signSprite.scale.set(2, 2, 1);
                    signSprite.position.y = 7;
                    marketGroup.add(signSprite);
                    
                    // Name label
                    const nameCanvas = document.createElement('canvas');
                    nameCanvas.width = 256;
                    nameCanvas.height = 64;
                    const nameCtx = nameCanvas.getContext('2d');
                    nameCtx.fillStyle = 'white';
                    nameCtx.strokeStyle = 'black';
                    nameCtx.lineWidth = 3;
                    nameCtx.font = 'bold 24px Arial';
                    nameCtx.textAlign = 'center';
                    nameCtx.textBaseline = 'middle';
                    nameCtx.strokeText(marketInfo.name, 128, 32);
                    nameCtx.fillText(marketInfo.name, 128, 32);
                    
                    const nameTexture = new THREE.CanvasTexture(nameCanvas);
                    const nameSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: nameTexture,
                        transparent: true
                    }));
                    nameSprite.scale.set(4, 1, 1);
                    nameSprite.position.y = 8.5;
                    marketGroup.add(nameSprite);
                    
                    // Collision box for hovering
                    const collisionBox = new THREE.Mesh(
                        new THREE.BoxGeometry(10, 8, 10),
                        new THREE.MeshBasicMaterial({ visible: false })
                    );
                    collisionBox.position.y = 3;
                    marketGroup.add(collisionBox);
                    
                    marketGroup.position.set(marketInfo.x, marketInfo.y, marketInfo.z);
                    scene.add(marketGroup);
                    
                    markets.set(marketInfo.id, {
                        mesh: marketGroup,
                        data: marketInfo
                    });
                }
            });
            
            // Remove markets that no longer exist
            markets.forEach((market, id) => {
                if (!currentMarketIds.has(id)) {
                    scene.remove(market.mesh);
                    markets.delete(id);
                }
            });
        }
        
        // Update buildings in the scene
        function updateBuildings(buildingData) {
            const currentBuildingIds = new Set();
            
            buildingData.forEach(buildingInfo => {
                currentBuildingIds.add(buildingInfo.id);
                
                const existing = buildings.get(buildingInfo.id);
                
                if (!existing) {
                    // Create new building
                    const buildingGroup = new THREE.Group();
                    
                    // Building base/foundation
                    const baseGeometry = new THREE.BoxGeometry(10, 0.3, 10);
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4a4a });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 0.15;
                    buildingGroup.add(base);
                    
                    // Building structure (height based on type)
                    const buildingHeight = buildingInfo.building_type === 'Warehouse' ? 6 : 5;
                    const wallGeometry = new THREE.BoxGeometry(9, buildingHeight, 9);
                    const wallMaterial = new THREE.MeshStandardMaterial({ 
                        color: buildingInfo.construction_progress < 1.0 ? 0x8a7a6a : 0x6a5a4a,
                        roughness: 0.8,
                        opacity: Math.max(0.3, buildingInfo.construction_progress),
                        transparent: buildingInfo.construction_progress < 1.0
                    });
                    const walls = new THREE.Mesh(wallGeometry, wallMaterial);
                    walls.position.y = buildingHeight / 2 + 0.3;
                    walls.castShadow = true;
                    buildingGroup.add(walls);
                    
                    // Roof (only if mostly complete)
                    if (buildingInfo.construction_progress > 0.7) {
                        const roofGeometry = new THREE.ConeGeometry(7, 2, 4);
                        const roofMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0x8b4513,
                            roughness: 0.9
                        });
                        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                        roof.position.y = buildingHeight + 1.3;
                        roof.rotation.y = Math.PI / 4;
                        roof.castShadow = true;
                        buildingGroup.add(roof);
                    }
                    
                    // Scaffolding for incomplete buildings
                    if (buildingInfo.construction_progress < 1.0) {
                        const scaffoldMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xccaa44,
                            wireframe: true
                        });
                        const scaffoldGeometry = new THREE.BoxGeometry(11, buildingHeight + 2, 11);
                        const scaffold = new THREE.Mesh(scaffoldGeometry, scaffoldMaterial);
                        scaffold.position.y = (buildingHeight + 2) / 2;
                        buildingGroup.add(scaffold);
                    }
                    
                    // Progress bar above building
                    if (buildingInfo.construction_progress < 1.0) {
                        const barWidth = 8;
                        const barHeight = 0.5;
                        
                        // Background
                        const bgGeometry = new THREE.PlaneGeometry(barWidth, barHeight);
                        const bgMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
                        const bg = new THREE.Mesh(bgGeometry, bgMaterial);
                        bg.position.set(0, buildingHeight + 3, 0);
                        buildingGroup.add(bg);
                        
                        // Progress fill
                        const progress = buildingInfo.construction_progress;
                        const fillGeometry = new THREE.PlaneGeometry(barWidth * progress, barHeight);
                        const fillMaterial = new THREE.MeshBasicMaterial({ color: 0x44ff44 });
                        const fill = new THREE.Mesh(fillGeometry, fillMaterial);
                        fill.position.set(-barWidth/2 + (barWidth * progress) / 2, buildingHeight + 3, 0.01);
                        buildingGroup.add(fill);
                    }
                    
                    // Name label
                    const nameCanvas = document.createElement('canvas');
                    nameCanvas.width = 512;
                    nameCanvas.height = 128;
                    const nameCtx = nameCanvas.getContext('2d');
                    nameCtx.fillStyle = 'white';
                    nameCtx.strokeStyle = 'black';
                    nameCtx.lineWidth = 4;
                    nameCtx.font = 'bold 48px Arial';
                    nameCtx.textAlign = 'center';
                    nameCtx.textBaseline = 'middle';
                    
                    const labelText = buildingInfo.construction_progress < 1.0 ? 
                        `üèóÔ∏è ${buildingInfo.name} (${Math.floor(buildingInfo.construction_progress * 100)}%)` :
                        buildingInfo.name;
                    
                    nameCtx.strokeText(labelText, 256, 64);
                    nameCtx.fillText(labelText, 256, 64);
                    
                    const nameTexture = new THREE.CanvasTexture(nameCanvas);
                    const nameSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                        map: nameTexture,
                        transparent: true
                    }));
                    nameSprite.scale.set(8, 2, 1);
                    nameSprite.position.y = buildingHeight + 4.5;
                    buildingGroup.add(nameSprite);
                    
                    // Collision box for hovering
                    const collisionBox = new THREE.Mesh(
                        new THREE.BoxGeometry(12, buildingHeight + 2, 12),
                        new THREE.MeshBasicMaterial({ visible: false })
                    );
                    collisionBox.position.y = (buildingHeight + 2) / 2;
                    buildingGroup.add(collisionBox);
                    
                    buildingGroup.position.set(buildingInfo.x, buildingInfo.y, buildingInfo.z);
                    scene.add(buildingGroup);
                    
                    buildings.set(buildingInfo.id, {
                        mesh: buildingGroup,
                        data: buildingInfo
                    });
                    
                    console.log(`üèóÔ∏è Building created: ${buildingInfo.name} (${Math.floor(buildingInfo.construction_progress * 100)}% complete)`);
                } else {
                    // Update existing building (mainly for construction progress)
                    if (buildingInfo.construction_progress !== existing.data.construction_progress) {
                        // Remove old building and recreate to show updated progress
                        scene.remove(existing.mesh);
                        buildings.delete(buildingInfo.id);
                        
                        // Will be recreated on next call
                        currentBuildingIds.delete(buildingInfo.id);
                        
                        if (buildingInfo.construction_progress >= 1.0) {
                            console.log(`‚úÖ Building completed: ${buildingInfo.name}`);
                        }
                    }
                }
            });
            
            // Remove buildings that no longer exist
            buildings.forEach((building, id) => {
                if (!currentBuildingIds.has(id)) {
                    scene.remove(building.mesh);
                    buildings.delete(id);
                }
            });
        }
        
        // Update currency information display
        function updateCurrencyInfo(currencyInfo) {
            if (currencyInfo.total_supply !== undefined) {
                document.getElementById('currency-supply').textContent = Math.floor(currencyInfo.total_supply);
                document.getElementById('currency-inflation').textContent = (currencyInfo.inflation_rate * 100).toFixed(2) + '%';
                document.getElementById('currency-power').textContent = (currencyInfo.purchasing_power * 100).toFixed(1) + '%';
                document.getElementById('currency-transactions').textContent = currencyInfo.transaction_count || 0;
            }
        }
        
        // Update economy dashboard with comprehensive data
        async function updateEconomyDashboard() {
            try {
                // Fetch world state for resource and market data
                const worldResponse = await fetch(`${API_URL}/api/world/state`);
                const worldData = await worldResponse.json();
                
                // Calculate resource totals
                const resourceTotals = {
                    wood: 0,
                    stone: 0,
                    food: 0,
                    iron: 0
                };
                
                (worldData.resources || []).forEach(resource => {
                    if (resource.resource_type === 'tree') resourceTotals.wood += resource.quantity;
                    else if (resource.resource_type === 'rock') resourceTotals.stone += resource.quantity;
                    else if (resource.resource_type === 'farm') resourceTotals.food += resource.quantity;
                    else if (resource.resource_type === 'iron') resourceTotals.iron += resource.quantity;
                });
                
                const agentCount = (worldData.agents || []).length;
                
                // Update currency metrics
                const currencyInfo = worldData.currency_info || {};
                document.getElementById('dash-money-supply').textContent = Math.floor(currencyInfo.total_supply || 20000).toLocaleString();
                document.getElementById('dash-inflation').textContent = ((currencyInfo.inflation_rate || 0) * 100).toFixed(2) + '%';
                document.getElementById('dash-purchasing').textContent = ((currencyInfo.purchasing_power || 1.0) * 100).toFixed(1) + '%';
                document.getElementById('dash-transactions').textContent = (currencyInfo.transaction_count || 0).toLocaleString();
                
                // Calculate velocity
                const velocity = currencyInfo.total_supply > 0 ? 
                    (currencyInfo.transaction_count || 0) / currencyInfo.total_supply : 0;
                document.getElementById('dash-velocity').textContent = velocity.toFixed(4);
                
                // Update market metrics
                const marketData = worldData.markets || [];
                document.getElementById('dash-market-count').textContent = marketData.length;
                
                const totalMarketTransactions = marketData.reduce((sum, m) => sum + (m.transaction_count || 0), 0);
                document.getElementById('dash-market-transactions').textContent = totalMarketTransactions.toLocaleString();
                
                const avgReputation = marketData.length > 0 ?
                    marketData.reduce((sum, m) => sum + (m.reputation || 50), 0) / marketData.length : 50;
                document.getElementById('dash-market-reputation').textContent = avgReputation.toFixed(1);
                
                // Count active traders
                const traderCount = (worldData.agents || []).filter(a => a.state === 'Trading').length;
                document.getElementById('dash-active-traders').textContent = traderCount;
                
                // Update resource supply
                document.getElementById('dash-supply-wood').textContent = resourceTotals.wood.toLocaleString();
                document.getElementById('dash-supply-stone').textContent = resourceTotals.stone.toLocaleString();
                document.getElementById('dash-supply-food').textContent = resourceTotals.food.toLocaleString();
                document.getElementById('dash-supply-iron').textContent = resourceTotals.iron.toLocaleString();
                
                // Update resource prices (mock data for now - will be dynamic later)
                const prices = {
                    wood: 5.0,
                    stone: 3.0,
                    food: 10.0,
                    iron: 15.0,
                    weapon: 50.0
                };
                
                // Update price displays and bars (scale to max 50 for visualization)
                const maxPrice = 50.0;
                document.getElementById('price-wood').textContent = prices.wood.toFixed(1);
                document.getElementById('price-bar-wood').style.width = (prices.wood / maxPrice * 100) + '%';
                
                document.getElementById('price-stone').textContent = prices.stone.toFixed(1);
                document.getElementById('price-bar-stone').style.width = (prices.stone / maxPrice * 100) + '%';
                
                document.getElementById('price-food').textContent = prices.food.toFixed(1);
                document.getElementById('price-bar-food').style.width = (prices.food / maxPrice * 100) + '%';
                
                document.getElementById('price-iron').textContent = prices.iron.toFixed(1);
                document.getElementById('price-bar-iron').style.width = (prices.iron / maxPrice * 100) + '%';
                
                document.getElementById('price-weapon').textContent = prices.weapon.toFixed(1);
                document.getElementById('price-bar-weapon').style.width = (prices.weapon / maxPrice * 100) + '%';
                
                // Calculate per capita resources
                const foodPerCapita = agentCount > 0 ? (resourceTotals.food / agentCount).toFixed(1) : 0;
                const materialsPerCapita = agentCount > 0 ? 
                    ((resourceTotals.wood + resourceTotals.stone + resourceTotals.iron) / agentCount).toFixed(1) : 0;
                
                document.getElementById('dash-food-per-capita').textContent = foodPerCapita;
                document.getElementById('dash-materials-per-capita').textContent = materialsPerCapita;
                
                // Update economic health indicators
                const foodPC = parseFloat(foodPerCapita);
                const matPC = parseFloat(materialsPerCapita);
                
                let economicStatus = 'Healthy';
                let resourceStress = 'Low';
                
                if (foodPC < 10 || matPC < 15) {
                    economicStatus = 'Critical';
                    resourceStress = 'Extreme';
                    document.getElementById('dash-economic-status').className = 'dashboard-metric-value metric-negative';
                    document.getElementById('dash-resource-stress').className = 'dashboard-metric-value metric-negative';
                } else if (foodPC < 20 || matPC < 30) {
                    economicStatus = 'Stressed';
                    resourceStress = 'High';
                    document.getElementById('dash-economic-status').className = 'dashboard-metric-value metric-neutral';
                    document.getElementById('dash-resource-stress').className = 'dashboard-metric-value metric-neutral';
                } else {
                    document.getElementById('dash-economic-status').className = 'dashboard-metric-value metric-positive';
                    document.getElementById('dash-resource-stress').className = 'dashboard-metric-value metric-positive';
                }
                
                document.getElementById('dash-economic-status').textContent = economicStatus;
                document.getElementById('dash-resource-stress').textContent = resourceStress;
                
                // Market activity
                const marketActivity = traderCount > 5 ? 'Very Active' : traderCount > 0 ? 'Active' : 'Quiet';
                document.getElementById('dash-market-activity').textContent = marketActivity;
                
                // Update market details list
                const marketDetailsList = document.getElementById('market-details-list');
                marketDetailsList.innerHTML = marketData.map(m => `
                    <div class="dashboard-metric">
                        <span class="dashboard-metric-label">${m.name}</span>
                        <span class="dashboard-metric-value" style="font-size: 12px;">${m.transaction_count || 0} txns</span>
                    </div>
                `).join('');
                
                // Color per-capita values based on thresholds
                const foodPerCapitaEl = document.getElementById('dash-food-per-capita');
                foodPerCapitaEl.className = foodPC < 10 ? 'dashboard-metric-value metric-negative' :
                    foodPC < 20 ? 'dashboard-metric-value metric-neutral' : 'dashboard-metric-value metric-positive';
                
                const matPerCapitaEl = document.getElementById('dash-materials-per-capita');
                matPerCapitaEl.className = matPC < 15 ? 'dashboard-metric-value metric-negative' :
                    matPC < 30 ? 'dashboard-metric-value metric-neutral' : 'dashboard-metric-value metric-positive';
                
            } catch (error) {
                console.error('Error updating economy dashboard:', error);
            }
        }
        
        // Animation loop
        let lastTime = Date.now();
        let frameCount = 0;
        let fps = 60;
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (!isPaused) {
                const time = Date.now() * 0.001;
                
                // Smooth agent movement with faster interpolation
                agents.forEach(agent => {
                    agent.mesh.position.lerp(agent.targetPos, 0.3); // Increased from 0.1 for snappier movement
                    
                    // Add subtle bobbing animation (breathing effect)
                    agent.mesh.position.y += Math.sin(time * 2 + agent.mesh.position.x) * 0.005;
                    
                    // Faster rotation for more active appearance
                    agent.mesh.rotation.y += 0.02; // Doubled from 0.01
                    
                    // Animate combat indicators if fighting
                    if (agent.combatIndicators) {
                        // Pulse the red ring
                        const pulseScale = 1 + Math.sin(time * 5) * 0.2; // Fast pulse
                        agent.combatIndicators.ring.scale.set(pulseScale, pulseScale, 1);
                        
                        // Pulse opacity
                        agent.combatIndicators.ring.material.opacity = 0.4 + Math.sin(time * 4) * 0.3;
                        
                        // Bounce the crossed swords icon
                        agent.combatIndicators.swordSprite.position.y = 3 + Math.sin(time * 3) * 0.3;
                        
                        // Rotate the swords slightly
                        agent.combatIndicators.swordSprite.material.rotation = Math.sin(time * 2) * 0.2;
                        
                        // Pulse the body glow for fighting agents
                        agent.body.material.emissiveIntensity = 0.6 + Math.sin(time * 6) * 0.3;
                    }
                });
                
                // Animate and clean up headstones
                const currentTime = Date.now();
                for (let i = headstones.length - 1; i >= 0; i--) {
                    const headstone = headstones[i];
                    const age = currentTime - headstone.createdAt;
                    
                    if (age > headstone.lifetime && !headstone.fadeStarted) {
                        // Start sinking after lifetime
                        headstone.fadeStarted = true;
                    }
                    
                    if (headstone.fadeStarted) {
                        // Slowly sink into ground
                        headstone.group.position.y -= 0.01;
                        
                        // Fade out opacity
                        headstone.group.children.forEach(child => {
                            if (child.material) {
                                if (!child.material.transparent) {
                                    child.material.transparent = true;
                                }
                                child.material.opacity = Math.max(0, child.material.opacity - 0.01);
                            }
                        });
                        
                        // Remove when fully sunk
                        if (headstone.group.position.y < -2) {
                            scene.remove(headstone.group);
                            headstones.splice(i, 1);
                        }
                    }
                }
                
                controls.update();
                renderer.render(scene, camera);
            }
            
            // Calculate FPS
            frameCount++;
            const currentTime = Date.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Mouse movement for tooltips
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check for agent intersections first
            const agentMeshes = Array.from(agents.values()).map(a => a.mesh);
            const agentIntersects = raycaster.intersectObjects(agentMeshes, true);
            
            if (agentIntersects.length > 0) {
                const hoveredMesh = agentIntersects[0].object.parent || agentIntersects[0].object;
                
                // Find which agent this mesh belongs to
                for (const [id, agent] of agents) {
                    if (agent.mesh === hoveredMesh) {
                        showAgentTooltip(agent, event.clientX, event.clientY);
                        return;
                    }
                }
            }
            
            // Check for resource intersections
            const resourceMeshes = Array.from(resources.values()).map(r => r.mesh);
            const resourceIntersects = raycaster.intersectObjects(resourceMeshes, true);
            
            if (resourceIntersects.length > 0) {
                const hoveredMesh = resourceIntersects[0].object.parent || resourceIntersects[0].object;
                
                // Find which resource this mesh belongs to
                for (const [id, resource] of resources) {
                    if (resource.mesh === hoveredMesh) {
                        showResourceTooltip(resource, event.clientX, event.clientY);
                        return;
                    }
                }
            }
            
            // Check for market intersections
            const marketMeshes = Array.from(markets.values()).map(m => m.mesh);
            const marketIntersects = raycaster.intersectObjects(marketMeshes, true);
            
            if (marketIntersects.length > 0) {
                const hoveredMesh = marketIntersects[0].object.parent || marketIntersects[0].object;
                
                // Find which market this mesh belongs to
                for (const [id, market] of markets) {
                    if (market.mesh === hoveredMesh) {
                        showMarketTooltip(market, event.clientX, event.clientY);
                        return;
                    }
                }
            }
            
            hideTooltip();
        }
        
        function onClick(event) {
            // Could add click interactions here
        }
        
        // Show tooltip for agent
        function showAgentTooltip(agent, x, y) {
            const tooltip = document.getElementById('tooltip');
            const data = agent.agentData || {};
            
            // Get social class icon
            const socialClass = data.social_class || 'Peasant';
            const classStyle = CLASS_STYLES[socialClass] || CLASS_STYLES['Peasant'];
            
            tooltip.innerHTML = `
                <h4>${classStyle.icon} ${agent.name}</h4>
                <div class="tooltip-row">
                    <span class="tooltip-label">Class:</span>
                    <span class="tooltip-value">${socialClass}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">State:</span>
                    <span class="tooltip-value">${agent.state}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Faction:</span>
                    <span class="tooltip-value">${agent.faction ? '‚öîÔ∏è At War' : 'None'}</span>
                </div>
                ${data.leader_id ? `
                <div class="tooltip-row">
                    <span class="tooltip-label">Leader:</span>
                    <span class="tooltip-value">üëë Following</span>
                </div>
                ` : ''}
                <div class="tooltip-row">
                    <span class="tooltip-label">Position:</span>
                    <span class="tooltip-value">
                        ${agent.mesh.position.x.toFixed(1)}, 
                        ${agent.mesh.position.z.toFixed(1)}
                    </span>
                </div>
            `;
            
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.style.display = 'block';
        }
        
        // Show tooltip for resource
        function showResourceTooltip(resource, x, y) {
            const tooltip = document.getElementById('tooltip');
            const data = resource.data || {};
            
            // Resource type icons and names
            const resourceDisplay = {
                'tree': { icon: 'üå≥', name: 'Tree', color: '#2d5016' },
                'rock': { icon: 'ü™®', name: 'Rock', color: '#666666' },
                'farm': { icon: 'üåæ', name: 'Farm', color: '#8b4513' },
                'iron': { icon: '‚õèÔ∏è', name: 'Iron Deposit', color: '#708090' }
            };
            
            const display = resourceDisplay[resource.type] || { icon: '‚ùì', name: resource.type, color: '#888888' };
            
            tooltip.innerHTML = `
                <h4>${display.icon} ${display.name}</h4>
                <div class="tooltip-row">
                    <span class="tooltip-label">Quantity:</span>
                    <span class="tooltip-value">${data.quantity || 0}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Position:</span>
                    <span class="tooltip-value">
                        ${(data.x || 0).toFixed(1)}, 
                        ${(data.z || 0).toFixed(1)}
                    </span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">ID:</span>
                    <span class="tooltip-value" style="font-size: 9px;">${data.id || 'Unknown'}</span>
                </div>
            `;
            
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.style.display = 'block';
        }
        
        // Show tooltip for market
        function showMarketTooltip(market, x, y) {
            const tooltip = document.getElementById('tooltip');
            const data = market.data || {};
            
            // Market type icons
            const marketIcons = {
                'general': 'üè™',
                'food': 'üçû',
                'materials': '‚öíÔ∏è',
                'luxury': 'üíé',
                'weapons': '‚öîÔ∏è'
            };
            
            const icon = marketIcons[data.market_type] || 'üè™';
            const typeName = (data.market_type || 'general').charAt(0).toUpperCase() + (data.market_type || 'general').slice(1);
            
            tooltip.innerHTML = `
                <h4>${icon} ${data.name || 'Market'}</h4>
                <div class="tooltip-row">
                    <span class="tooltip-label">Type:</span>
                    <span class="tooltip-value">${typeName} Market</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Transactions:</span>
                    <span class="tooltip-value">${data.transaction_count || 0}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Reputation:</span>
                    <span class="tooltip-value">${(data.reputation || 50).toFixed(1)}/100</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Position:</span>
                    <span class="tooltip-value">
                        ${(data.x || 0).toFixed(1)}, 
                        ${(data.z || 0).toFixed(1)}
                    </span>
                </div>
            `;
            
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.style.display = 'block';
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        // Log activity to feed
        function logActivity(message, type) {
            // Deduplicate - don't add if same message exists recently
            if (activityLog.length > 0 && activityLog[0].message === message) {
                return;
            }
            
            const timestamp = new Date().toLocaleTimeString();
            activityLog.unshift({ message, timestamp, type });
            
            // Keep only last 20 items
            if (activityLog.length > 20) {
                activityLog.pop();
            }
            
            // Update display
            const activityList = document.getElementById('activity-list');
            if (activityList) {
                activityList.innerHTML = activityLog.map(item => `
                    <div class="activity-item">
                        <div>${item.message}</div>
                        <div class="activity-time">${item.timestamp}</div>
                    </div>
                `).join('');
            }
        }
        
        // Switch all agents to faction colors
        function showFactionColors() {
            if (showingFactionColors) return;
            showingFactionColors = true;
            
            agents.forEach(agent => {
                // Skip fighting agents (they should stay red)
                if (agent.state === 'Fighting') return;
                
                const agentData = agent.agentData || {};
                if (agentData.faction) {
                    // Determine faction color
                    const factionKey = agentData.faction.includes('2cf7e1d2') ? 'Kingdom A' : 'Kingdom B';
                    const factionColor = new THREE.Color(FACTION_COLORS[factionKey]);
                    
                    agent.body.material.color = factionColor;
                    agent.body.material.emissive = factionColor;
                    agent.head.material.color = factionColor;
                }
            });
        }
        
        // Switch all agents back to state colors
        function showStateColors() {
            if (!showingFactionColors) return;
            showingFactionColors = false;
            
            agents.forEach(agent => {
                // Skip fighting agents (they should stay red)
                if (agent.state === 'Fighting') return;
                
                const state = agent.state || 'Idle';
                const stateColor = new THREE.Color(STATE_COLORS[state] || STATE_COLORS['Idle']);
                
                agent.body.material.color = stateColor;
                agent.body.material.emissive = stateColor;
                agent.head.material.color = stateColor;
            });
        }
        
        // Global functions for UI
        window.resetCamera = function() {
            camera.position.set(70, 60, 70);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        };
        
        window.togglePause = function() {
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');
            btn.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
        };
        
        window.testCombat = function() {
            // Force a few random agents into fighting state for testing
            const agentArray = Array.from(agents.values());
            if (agentArray.length < 2) {
                alert('Need at least 2 agents to test combat!');
                return;
            }
            
            // Pick 3-5 random agents and force them to fight
            const numFighters = Math.min(Math.floor(Math.random() * 3) + 3, agentArray.length);
            const fighters = [];
            
            for (let i = 0; i < numFighters; i++) {
                const randomIndex = Math.floor(Math.random() * agentArray.length);
                fighters.push(agentArray[randomIndex]);
            }
            
            // Set them all to fighting state
            fighters.forEach(agent => {
                agent.state = 'Fighting';
                
                // Change body color to red
                agent.body.material.emissiveIntensity = 0.8;
                agent.body.material.emissive = new THREE.Color(0xff0000);
                
                // Add combat indicators
                addCombatIndicators(agent);
            });
            
            showNotification('‚öîÔ∏è Combat Test', `Forced ${numFighters} agents into combat mode!`);
            logActivity(`‚öîÔ∏è Combat test activated - ${numFighters} agents fighting`, 'combat');
            
            // Automatically remove indicators after 10 seconds
            setTimeout(() => {
                fighters.forEach(agent => {
                    if (agents.has(agent.mesh.uuid)) {
                        removeCombatIndicators(agent);
                        agent.state = 'Idle';
                        agent.body.material.emissiveIntensity = 0.2;
                        
                        // Reset to state color (unless showing faction colors)
                        const stateColor = new THREE.Color(STATE_COLORS['Idle']);
                        agent.body.material.color = stateColor;
                        agent.body.material.emissive = stateColor;
                        agent.head.material.color = stateColor;
                        
                        // Re-apply faction colors if hovering
                        if (showingFactionColors && agent.agentData && agent.agentData.faction) {
                            const factionKey = agent.agentData.faction.includes('2cf7e1d2') ? 'Kingdom A' : 'Kingdom B';
                            const factionColor = new THREE.Color(FACTION_COLORS[factionKey]);
                            agent.body.material.color = factionColor;
                            agent.body.material.emissive = factionColor;
                            agent.head.material.color = factionColor;
                        }
                    }
                });
                showNotification('‚úÖ Combat Test Ended', 'Agents returned to normal');
            }, 10000);
        };
        
        window.testBuilding = function() {
            showNotification('üèóÔ∏è Building System', 'An incomplete "Test Construction Site" exists at (0, -35)');
            logActivity(`üèóÔ∏è Building system active - Builders auto-construct incomplete buildings`, 'info');
            
            alert('üèóÔ∏è Building System is Active!\n\n' +
                  '‚úÖ There\'s a "Test Construction Site" at coordinates (0, -35)\n' +
                  '‚úÖ Builders (Job::Builder) automatically find incomplete buildings\n' +
                  '‚úÖ Construction progress: 2% per builder per second\n' +
                  '‚úÖ Watch the progress bar above the building!\n' +
                  '‚úÖ Scaffolding disappears when building is complete\n\n' +
                  'Look for the building with wireframe scaffolding and green progress bar!');
            
            // Pan camera to the construction site
            camera.position.set(0, 30, -20);
            camera.lookAt(0, 0, -35);
            controls.target.set(0, 0, -35);
            controls.update();
        };
        
        window.toggleEconomyDashboard = function() {
            const dashboard = document.getElementById('economy-dashboard');
            dashboard.classList.toggle('visible');
            
            // Update dashboard data when opened
            if (dashboard.classList.contains('visible')) {
                updateEconomyDashboard();
            }
        };
        
        // Open trading chart for a specific resource
        window.openTradingChart = function(resourceType, resourceName) {
            currentTradingResource = resourceType;
            
            const modal = document.getElementById('trading-chart-modal');
            modal.classList.add('visible');
            
            document.getElementById('trading-chart-title').textContent = `üìà ${resourceName} Trading Chart`;
            
            // Start updating price history
            updateTradingChart();
            
            // Update chart every 2 seconds
            if (priceHistoryInterval) clearInterval(priceHistoryInterval);
            priceHistoryInterval = setInterval(updateTradingChart, 2000);
        };
        
        window.closeTradingChart = function() {
            const modal = document.getElementById('trading-chart-modal');
            modal.classList.remove('visible');
            currentTradingResource = null;
            
            // Stop updating
            if (priceHistoryInterval) {
                clearInterval(priceHistoryInterval);
                priceHistoryInterval = null;
            }
        };
        
        // Calculate price for a specific resource based on current supply
        function calculateResourcePrice(resourceType, resourceTotals) {
            // Base prices
            const basePrices = {
                wood: 5.0,
                stone: 3.0,
                food: 10.0,
                iron: 15.0,
                weapon: 50.0
            };
            
            // Calculate dynamic price based on supply (simple model)
            const initialSupply = {
                wood: 5000,   // Rough starting amount
                stone: 4000,
                food: 6000,
                iron: 3000
            };
            
            let currentPrice = basePrices[resourceType] || 5.0;
            
            // Price increases as supply decreases (supply/demand)
            if (resourceType !== 'weapon') {
                const supply = resourceTotals[resourceType] || 0;
                const initial = initialSupply[resourceType] || 1000;
                const scarcityFactor = initial / Math.max(supply, 100); // Prevent division by zero
                currentPrice = basePrices[resourceType] * scarcityFactor;
                currentPrice = Math.max(currentPrice, basePrices[resourceType] * 0.5); // Floor at 50%
                currentPrice = Math.min(currentPrice, basePrices[resourceType] * 5.0); // Cap at 500%
            }
            
            return currentPrice;
        }
        
        // Track all resource prices in the background (runs continuously)
        async function trackAllResourcePrices() {
            try {
                // Fetch world state for resource calculations
                const worldResponse = await fetch(`${API_URL}/api/world/state`);
                const worldData = await worldResponse.json();
                
                // Calculate current resource supply
                const resourceTotals = {
                    wood: 0,
                    stone: 0,
                    food: 0,
                    iron: 0
                };
                
                (worldData.resources || []).forEach(resource => {
                    if (resource.resource_type === 'tree') resourceTotals.wood += resource.quantity;
                    else if (resource.resource_type === 'rock') resourceTotals.stone += resource.quantity;
                    else if (resource.resource_type === 'farm') resourceTotals.food += resource.quantity;
                    else if (resource.resource_type === 'iron') resourceTotals.iron += resource.quantity;
                });
                
                const timestamp = Date.now();
                
                // Calculate and store price for each resource
                ['wood', 'stone', 'food', 'iron', 'weapon'].forEach(resourceType => {
                    const price = calculateResourcePrice(resourceType, resourceTotals);
                    
                    const history = priceHistory[resourceType];
                    history.push({
                        time: timestamp,
                        price: price
                    });
                    
                    // Keep limited history
                    if (history.length > MAX_PRICE_HISTORY) {
                        history.shift();
                    }
                });
                
            } catch (error) {
                console.error('Error tracking prices:', error);
            }
        }
        
        // Start background price tracking
        function startBackgroundPriceTracking() {
            if (backgroundPriceTracking) {
                clearInterval(backgroundPriceTracking);
            }
            
            // Track prices immediately
            trackAllResourcePrices();
            
            // Then track every 2 seconds
            backgroundPriceTracking = setInterval(trackAllResourcePrices, 2000);
            
            console.log('üìà Background price tracking started (every 2 seconds)');
        }
        
        // Update trading chart display (uses pre-tracked history from background)
        async function updateTradingChart() {
            if (!currentTradingResource) return;
            
            try {
                // Get the already-tracked price history (built by background tracking)
                const history = priceHistory[currentTradingResource];
                
                if (history.length === 0) {
                    console.log('No price history yet for ' + currentTradingResource);
                    return;
                }
                
                // Calculate stats from existing history
                const prices = history.map(h => h.price);
                const currentPrice = prices[prices.length - 1] || 0;
                const highPrice = Math.max(...prices);
                const lowPrice = Math.min(...prices);
                const firstPrice = history[0]?.price || currentPrice;
                const priceChange = firstPrice > 0 ? ((currentPrice - firstPrice) / firstPrice * 100) : 0;
                
                // Update stats display
                document.getElementById('trading-current-price').textContent = currentPrice.toFixed(2);
                document.getElementById('trading-high-price').textContent = highPrice.toFixed(2);
                document.getElementById('trading-low-price').textContent = lowPrice.toFixed(2);
                
                const changeEl = document.getElementById('trading-price-change');
                changeEl.textContent = (priceChange >= 0 ? '+' : '') + priceChange.toFixed(2) + '%';
                changeEl.className = priceChange >= 0 ? 'trading-stat-value metric-positive' : 'trading-stat-value metric-negative';
                
                // Draw the chart with all historical data
                drawPriceChart(history);
                
            } catch (error) {
                console.error('Error updating trading chart:', error);
            }
        }
        
        // Draw price history chart (line chart like stock trading)
        function drawPriceChart(history) {
            const canvas = document.getElementById('price-history-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match container
            const container = canvas.parentElement;
            canvas.width = container.clientWidth - 40;
            canvas.height = container.clientHeight - 40;
            
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.0)';
            ctx.fillRect(0, 0, width, height);
            
            if (history.length < 2) {
                // Not enough data yet
                ctx.fillStyle = '#888';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Collecting price data...', width / 2, height / 2);
                return;
            }
            
            // Find min/max for scaling
            const prices = history.map(h => h.price);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            const priceRange = maxPrice - minPrice || 1;
            
            // Add padding
            const padding = 50;
            const chartWidth = width - padding * 2;
            const chartHeight = height - padding * 2;
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
                
                // Price labels
                const price = maxPrice - (priceRange / 5) * i;
                ctx.fillStyle = '#888';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(price.toFixed(2), padding - 10, y + 4);
            }
            
            // Draw price line
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            history.forEach((point, index) => {
                const x = padding + (chartWidth / (history.length - 1)) * index;
                const normalizedPrice = (point.price - minPrice) / priceRange;
                const y = padding + chartHeight - (normalizedPrice * chartHeight);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Fill area under line
            ctx.lineTo(width - padding, height - padding);
            ctx.lineTo(padding, height - padding);
            ctx.closePath();
            ctx.fillStyle = 'rgba(243, 156, 18, 0.2)';
            ctx.fill();
            
            // Draw data points
            ctx.fillStyle = '#f39c12';
            history.forEach((point, index) => {
                const x = padding + (chartWidth / (history.length - 1)) * index;
                const normalizedPrice = (point.price - minPrice) / priceRange;
                const y = padding + chartHeight - (normalizedPrice * chartHeight);
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Current price indicator (last point, larger)
            if (history.length > 0) {
                const lastPoint = history[history.length - 1];
                const x = padding + chartWidth;
                const normalizedPrice = (lastPoint.price - minPrice) / priceRange;
                const y = padding + chartHeight - (normalizedPrice * chartHeight);
                
                ctx.fillStyle = '#2ecc71';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Price label
                ctx.fillStyle = '#2ecc71';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(lastPoint.price.toFixed(2), x + 10, y + 5);
            }
            
            // Time axis labels with actual timestamps
            ctx.fillStyle = '#888';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            if (history.length > 0) {
                const firstTime = history[0].time;
                const lastTime = history[history.length - 1].time;
                const timeSpanSeconds = Math.floor((lastTime - firstTime) / 1000);
                const minutes = Math.floor(timeSpanSeconds / 60);
                const seconds = timeSpanSeconds % 60;
                
                const timeSpanText = minutes > 0 ? 
                    `${minutes}m ${seconds}s` : 
                    `${seconds}s`;
                
                ctx.fillText(`‚Üê ${timeSpanText} ago`, padding + 60, height - padding + 20);
                ctx.fillText('Now ‚Üí', width - padding - 50, height - padding + 20);
            }
            
            // Chart title with time range
            ctx.fillStyle = '#f39c12';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            
            const dataPoints = history.length;
            const timeRangeMinutes = Math.floor((dataPoints * 2) / 60); // 2s per update
            const timeRangeText = timeRangeMinutes > 0 ? 
                `${timeRangeMinutes}m ${dataPoints % 30 * 2}s` : 
                `${dataPoints * 2}s`;
            
            ctx.fillText(`Price History - ${dataPoints} data points (~${timeRangeText} range)`, width / 2, 25);
        }
        
        // Show notification toast
        function showNotification(title, body) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `
                <div class="notification-title">${title}</div>
                <div class="notification-body">${body}</div>
            `;
            document.body.appendChild(notification);
            
            // Remove after animation completes
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // Show dramatic event notification (larger, more prominent)
        function showDramaticNotification(icon, title, description, color) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.style.background = `linear-gradient(135deg, ${color}dd, ${color}aa)`;
            notification.style.border = `3px solid ${color}`;
            notification.style.minWidth = '400px';
            notification.style.fontSize = '16px';
            notification.style.boxShadow = `0 8px 32px ${color}88`;
            
            notification.innerHTML = `
                <div style="font-size: 48px; text-align: center; margin-bottom: 10px;">${icon}</div>
                <div class="notification-title" style="font-size: 24px; text-align: center;">${title}</div>
                <div class="notification-body" style="font-size: 14px; text-align: center; margin-top: 8px;">${description}</div>
            `;
            document.body.appendChild(notification);
            
            // Remove after longer duration for dramatic events
            setTimeout(() => {
                notification.remove();
            }, 6000);
        }
        
        // Add combat visual indicators (crossed swords + red ring)
        function addCombatIndicators(agent) {
            // Don't add if already fighting
            if (agent.combatIndicators) return;
            
            // Create crossed swords icon above head
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Draw crossed swords emoji/text
            ctx.font = 'bold 100px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚öîÔ∏è', 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false // Always visible on top
            });
            const swordSprite = new THREE.Sprite(spriteMaterial);
            swordSprite.scale.set(1.5, 1.5, 1);
            swordSprite.position.y = 3; // Above head
            agent.mesh.add(swordSprite);
            
            // Create pulsing red ring on ground
            const ringGeometry = new THREE.RingGeometry(1.2, 1.8, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2; // Lay flat
            ring.position.y = 0.1; // Slightly above ground
            agent.mesh.add(ring);
            
            // Store references for removal and animation
            agent.combatIndicators = {
                swordSprite: swordSprite,
                ring: ring
            };
        }
        
        // Remove combat visual indicators
        function removeCombatIndicators(agent) {
            if (agent.combatIndicators) {
                agent.mesh.remove(agent.combatIndicators.swordSprite);
                agent.mesh.remove(agent.combatIndicators.ring);
                agent.combatIndicators = null;
            }
        }
        
        // Add speech bubble for talking agents
        function addSpeechBubble(agent) {
            // Don't add if already has bubble
            if (agent.speechBubble) return;
            
            // Create speech bubble sprite
            const bubbleCanvas = document.createElement('canvas');
            bubbleCanvas.width = 256;
            bubbleCanvas.height = 128;
            const ctx = bubbleCanvas.getContext('2d');
            
            // Draw speech bubble background
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 4;
            
            // Rounded rectangle for bubble
            const x = 20, y = 10, w = 216, h = 80, r = 15;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Speech bubble tail (triangle pointing down)
            ctx.beginPath();
            ctx.moveTo(100, 90);
            ctx.lineTo(120, 110);
            ctx.lineTo(140, 90);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Add text dots to indicate talking
            ctx.fillStyle = '#333';
            ctx.font = 'bold 40px Arial';
            ctx.fillText('üí¨', 128, 50);
            
            const texture = new THREE.CanvasTexture(bubbleCanvas);
            const bubbleSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0.9
            }));
            bubbleSprite.scale.set(2, 1, 1);
            bubbleSprite.position.y = 3.5;
            agent.mesh.add(bubbleSprite);
            
            agent.speechBubble = bubbleSprite;
        }
        
        // Remove speech bubble
        function removeSpeechBubble(agent) {
            if (agent.speechBubble) {
                agent.mesh.remove(agent.speechBubble);
                agent.speechBubble = null;
            }
        }
        
        // Combat particle effect
        function createCombatEffect(position) {
            const particleCount = 20;
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xff6600,
                    transparent: true,
                    opacity: 1.0
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 2,
                    (Math.random() - 0.5) * 2
                );
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Animate particles
            let life = 0;
            const animateParticles = () => {
                life += 0.05;
                particles.children.forEach(p => {
                    p.position.add(p.velocity);
                    p.velocity.y -= 0.05; // Gravity
                    p.material.opacity = 1.0 - life;
                });
                
                if (life < 1.0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                }
            };
            animateParticles();
        }
        
        // Create headstone/grave marker at death location
        function createHeadstone(position, agentName) {
            const headstoneGroup = new THREE.Group();
            
            // Grave base (dark mound)
            const moundGeometry = new THREE.CylinderGeometry(1.2, 1.5, 0.3, 8);
            const moundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2d1810,
                roughness: 0.9
            });
            const mound = new THREE.Mesh(moundGeometry, moundMaterial);
            mound.position.y = 0.15;
            headstoneGroup.add(mound);
            
            // Headstone (vertical stone)
            const stoneGeometry = new THREE.BoxGeometry(1.2, 1.5, 0.2);
            const stoneMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a4a4a,
                roughness: 0.8
            });
            const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
            stone.position.y = 1.0;
            stone.castShadow = true;
            headstoneGroup.add(stone);
            
            // Skull emoji on headstone
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üíÄ', 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const skullSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            }));
            skullSprite.scale.set(0.8, 0.8, 1);
            skullSprite.position.set(0, 1.2, 0.15);
            headstoneGroup.add(skullSprite);
            
            // Name label (floating text above)
            const nameCanvas = document.createElement('canvas');
            nameCanvas.width = 256;
            nameCanvas.height = 64;
            const nameCtx = nameCanvas.getContext('2d');
            nameCtx.fillStyle = 'white';
            nameCtx.strokeStyle = 'black';
            nameCtx.lineWidth = 3;
            nameCtx.font = 'bold 32px Arial';
            nameCtx.textAlign = 'center';
            nameCtx.textBaseline = 'middle';
            nameCtx.strokeText(agentName, 128, 32);
            nameCtx.fillText(agentName, 128, 32);
            
            const nameTexture = new THREE.CanvasTexture(nameCanvas);
            const nameSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                map: nameTexture,
                transparent: true
            }));
            nameSprite.scale.set(3, 0.75, 1);
            nameSprite.position.set(0, 2.2, 0);
            headstoneGroup.add(nameSprite);
            
            // Add cross on top
            const crossVertical = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.5, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x8b7355 })
            );
            crossVertical.position.set(0, 2.0, 0);
            headstoneGroup.add(crossVertical);
            
            const crossHorizontal = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.1, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x8b7355 })
            );
            crossHorizontal.position.set(0, 1.9, 0);
            headstoneGroup.add(crossHorizontal);
            
            // Position at death location
            headstoneGroup.position.copy(position);
            headstoneGroup.position.y = 0;
            
            scene.add(headstoneGroup);
            
            // Store headstone data for later removal/animation
            const headstoneData = {
                group: headstoneGroup,
                createdAt: Date.now(),
                lifetime: 45000, // 45 seconds before starting to sink
                fadeStarted: false
            };
            headstones.push(headstoneData);
        }
        
        // Death explosion effect
        function createDeathEffect(position) {
            const particleCount = 30;
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.15, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x888888,
                    transparent: true,
                    opacity: 1.0
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    Math.random() * 3 + 1,
                    (Math.random() - 0.5) * 3
                );
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Animate explosion
            let life = 0;
            const animateExplosion = () => {
                life += 0.03;
                particles.children.forEach(p => {
                    p.position.add(p.velocity);
                    p.velocity.y -= 0.08; // Gravity
                    p.material.opacity = 1.0 - life;
                });
                
                if (life < 1.0) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(particles);
                }
            };
            animateExplosion();
        }
        
        // Start the visualizer
        init();
        
        // Start background price tracking immediately
        startBackgroundPriceTracking();
        
        console.log('üåç World Simulation Visualizer Started');
        console.log('API: ' + API_URL);
        console.log('State Colors:', STATE_COLORS);
    </script>
</body>
</html>

