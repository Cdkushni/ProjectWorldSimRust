<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç World Simulation Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a1a;
            color: #eee;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            min-width: 250px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #stats h2 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 20px;
            font-weight: 600;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 12px 0;
            font-size: 14px;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
        }
        
        #connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }
        
        .connected {
            background: rgba(76, 175, 80, 0.9);
            border: 2px solid #4caf50;
        }
        
        .disconnected {
            background: rgba(244, 67, 54, 0.9);
            border: 2px solid #f44336;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #controls button {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            border: none;
            color: #fff;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.3);
        }
        
        #controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.5);
        }
        
        #controls button:active {
            transform: translateY(0);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            color: #4ecdc4;
            text-align: center;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(78, 205, 196, 0.2);
            border-top-color: #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            font-size: 12px;
            color: #aaa;
            max-width: 200px;
        }
        
        #legend {
            position: absolute;
            top: 200px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 200px;
        }
        
        #legend h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 16px;
            font-weight: 600;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            font-size: 13px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .legend-label {
            color: #ddd;
            flex: 1;
        }
        
        .legend-count {
            color: #4ecdc4;
            font-weight: bold;
            margin-left: 10px;
        }
        
        #faction-stats {
            position: absolute;
            top: 430px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 250px;
        }
        
        #faction-stats h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 16px;
            font-weight: 600;
        }
        
        .faction-item {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }
        
        .faction-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .faction-count {
            font-size: 12px;
            color: #aaa;
        }
        
        #resource-stats {
            position: absolute;
            top: 620px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 250px;
        }
        
        #resource-stats h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 16px;
            font-weight: 600;
        }
        
        .resource-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 13px;
        }
        
        .resource-icon {
            margin-right: 8px;
        }
        
        #activity-feed {
            position: absolute;
            bottom: 120px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            max-width: 300px;
            max-height: 250px;
            overflow-y: auto;
        }
        
        #activity-feed h3 {
            margin-bottom: 10px;
            color: #4ecdc4;
            font-size: 14px;
            font-weight: 600;
        }
        
        .activity-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 11px;
            color: #ccc;
            border-left: 3px solid #4ecdc4;
        }
        
        .activity-time {
            color: #888;
            font-size: 10px;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            pointer-events: none;
            display: none;
            z-index: 2000;
            border: 2px solid #4ecdc4;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
            max-width: 300px;
        }
        
        #tooltip h4 {
            margin-bottom: 10px;
            color: #4ecdc4;
            font-size: 16px;
        }
        
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .tooltip-label {
            color: #aaa;
        }
        
        .tooltip-value {
            color: #fff;
            font-weight: bold;
        }
        
        .notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            border-left: 4px solid #4ecdc4;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease, slideOut 0.3s ease 2.7s;
            z-index: 1000;
            max-width: 300px;
        }
        
        .notification-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .notification-body {
            font-size: 12px;
            color: #ccc;
        }
        
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="stats">
        <h2>üìä Simulation Stats</h2>
        <div class="stat-item">
            <span class="stat-label">üßë Agents:</span>
            <span class="stat-value" id="agent-count">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">‚è±Ô∏è Uptime:</span>
            <span class="stat-value" id="uptime">0s</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">üì° Events:</span>
            <span class="stat-value" id="events">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">üéÆ FPS:</span>
            <span class="stat-value" id="fps">60</span>
        </div>
    </div>
    
    <div id="legend">
        <h3>üé® Agent States</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #4ecdc4;"></div>
            <span class="legend-label">Idle</span>
            <span class="legend-count" id="count-idle">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #95e1d3;"></div>
            <span class="legend-label">Moving</span>
            <span class="legend-count" id="count-moving">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b6b;"></div>
            <span class="legend-label">üî® Working</span>
            <span class="legend-count" id="count-working">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffd93d;"></div>
            <span class="legend-label">üçû Eating</span>
            <span class="legend-count" id="count-eating">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #9b59b6;"></div>
            <span class="legend-label">üí§ Sleeping</span>
            <span class="legend-count" id="count-sleeping">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #e74c3c;"></div>
            <span class="legend-label">‚öîÔ∏è Fighting</span>
            <span class="legend-count" id="count-fighting">0</span>
        </div>
    </div>
    
    <div id="faction-stats">
        <h3>‚öîÔ∏è Faction Status</h3>
        <div class="faction-item">
            <div class="faction-name" style="color: #3498db;">üîµ Kingdom A</div>
            <div class="faction-count" id="faction-a-count">0 agents</div>
        </div>
        <div class="faction-item">
            <div class="faction-name" style="color: #e74c3c;">üî¥ Kingdom B</div>
            <div class="faction-count" id="faction-b-count">0 agents</div>
        </div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
            <div class="faction-count">
                <span style="color: #ff6b6b;">üíÄ War Casualties:</span>
                <span id="casualties" style="color: #fff; font-weight: bold;">0</span>
            </div>
        </div>
    </div>
    
    <div id="resource-stats">
        <h3>üè≠ Resources</h3>
        <div class="resource-row">
            <span><span class="resource-icon">üå≤</span>Trees:</span>
            <span id="resource-tree" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
        <div class="resource-row">
            <span><span class="resource-icon">‚õ∞Ô∏è</span>Rocks:</span>
            <span id="resource-rock" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
        <div class="resource-row">
            <span><span class="resource-icon">üåæ</span>Farms:</span>
            <span id="resource-farm" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
        <div class="resource-row">
            <span><span class="resource-icon">‚öôÔ∏è</span>Iron:</span>
            <span id="resource-iron" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
    </div>
    
    <div id="activity-feed">
        <h3>üì° Live Activity</h3>
        <div id="activity-list"></div>
    </div>
    
    <div id="tooltip"></div>
    
    <div id="connection-status" class="disconnected">‚óè Connecting...</div>
    
    <div id="controls">
        <button onclick="resetCamera()">üé• Reset Camera</button>
        <button onclick="togglePause()" id="pauseBtn">‚è∏Ô∏è Pause</button>
        <button onclick="testCombat()">‚öîÔ∏è Test Combat</button>
    </div>
    
    <div id="info">
        <strong>üïπÔ∏è Controls:</strong><br>
        Left Mouse: Rotate<br>
        Right Mouse: Pan<br>
        Scroll: Zoom
    </div>
    
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        Loading Three.js...
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        const API_URL = 'http://127.0.0.1:8080';
        let scene, camera, renderer, controls;
        let agents = new Map();
        let resources = new Map();
        let isPaused = false;
        let terrainMesh;
        let lastEventCount = 0;
        let initialAgentCount = 100;
        let activityLog = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isInitialLoad = true;
        let knownAgentIds = new Set();
        let headstones = [];
        let showingFactionColors = false;
        let lastKnownEventId = null;
        let processedEventIds = new Set();
        
        // State-based colors
        const STATE_COLORS = {
            'Idle': 0x4ecdc4,      // Cyan
            'Moving': 0x95e1d3,    // Light cyan  
            'Working': 0xff6b6b,   // Red
            'Eating': 0xffd93d,    // Yellow
            'Sleeping': 0x9b59b6,  // Purple
            'Fighting': 0xe74c3c,  // Dark red
            'Dead': 0x555555       // Gray
        };
        
        // Faction colors (for team identification)
        const FACTION_COLORS = {
            'Kingdom A': 0x3498db,  // Blue team
            'Kingdom B': 0xe74c3c,  // Red team
        };
        
        // Initialize Three.js scene
        function init() {
            document.getElementById('loading').style.display = 'none';
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.Fog(0x0a0a1a, 150, 400);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(70, 60, 70);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 200;
            controls.maxPolarAngle = Math.PI / 2.1;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0x404060, 1.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(80, 120, 60);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // Hemisphere light for ambient atmosphere
            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x6b8e23, 0.5);
            scene.add(hemiLight);
            
            // Grid helper
            const gridHelper = new THREE.GridHelper(200, 40, 0x4ecdc4, 0x2a2a3e);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
            
            // Terrain plane
            const terrainGeometry = new THREE.PlaneGeometry(200, 200, 20, 20);
            const terrainMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a4d2e,
                roughness: 0.9,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            terrainMesh = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrainMesh.rotation.x = -Math.PI / 2;
            terrainMesh.receiveShadow = true;
            terrainMesh.position.y = 0;
            scene.add(terrainMesh);
            
            // Resources will be added dynamically from API
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Handle mouse movement for tooltips
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onClick);
            
            // Add faction UI hover listeners
            const factionStats = document.getElementById('faction-stats');
            if (factionStats) {
                factionStats.addEventListener('mouseenter', showFactionColors);
                factionStats.addEventListener('mouseleave', showStateColors);
            }
            
            // Start animation loop
            animate();
            
            // Start fetching data
            fetchWorldState();
            setInterval(fetchWorldState, 200); // Update every 0.2 seconds for smoother movement (was 500ms)
            fetchMetrics();
            setInterval(fetchMetrics, 1000);
            fetchEvents();
            setInterval(fetchEvents, 3000); // Check for new events every 3 seconds
        }
        
        
        // Fetch world state from API
        async function fetchWorldState() {
            try {
                const response = await fetch(`${API_URL}/api/world/state`);
                if (!response.ok) {
                    throw new Error('API returned ' + response.status);
                }
                const data = await response.json();
                
                // Check if we got valid data
                if (data && data.agents) {
                    updateConnectionStatus(true);
                    updateAgents(data.agents);
                    updateResources(data.resources || []);
                } else {
                    console.warn('Invalid data received:', data);
                    updateConnectionStatus(false);
                }
            } catch (error) {
                console.error('Error fetching world state:', error);
                updateConnectionStatus(false);
            }
        }
        
        // Fetch metrics from API
        async function fetchMetrics() {
            try {
                const response = await fetch(`${API_URL}/api/metrics`);
                if (!response.ok) throw new Error('API returned ' + response.status);
                const data = await response.json();
                
                document.getElementById('agent-count').textContent = data.agent_count || 0;
                document.getElementById('uptime').textContent = `${data.uptime_seconds || 0}s`;
                document.getElementById('events').textContent = data.events_processed || 0;
                
                // Check for new events
                if (data.events_processed > lastEventCount && lastEventCount > 0) {
                    showNotification('üì° New Event', 'Simulation event occurred');
                    logActivity('üì° Simulation event triggered', 'event');
                }
                lastEventCount = data.events_processed;
            } catch (error) {
                console.error('Error fetching metrics:', error);
            }
        }
        
        // Fetch simulation events
        async function fetchEvents() {
            try {
                const response = await fetch(`${API_URL}/api/events/history?limit=20`);
                if (!response.ok) return;
                
                const data = await response.json();
                const events = data.events || [];
                
                // Process new events (in reverse order, oldest first)
                events.reverse().forEach(event => {
                    // Skip if already processed
                    if (processedEventIds.has(event.id)) return;
                    
                    processedEventIds.add(event.id);
                    displayEvent(event);
                });
                
                // Keep set from growing too large
                if (processedEventIds.size > 100) {
                    const arr = Array.from(processedEventIds);
                    processedEventIds = new Set(arr.slice(-50));
                }
            } catch (error) {
                // Silent fail - events are optional
            }
        }
        
        // Display a simulation event with dramatic flair
        function displayEvent(event) {
            const eventType = event.event_type;
            const payload = event.payload || {};
            
            // Determine event styling based on type
            let icon = 'üì°';
            let title = 'Simulation Event';
            let description = 'Something happened';
            let color = '#4ecdc4';
            let logType = 'event';
            
            switch (eventType) {
                case 'DungeonMaster':
                    icon = 'üé≠';
                    title = payload.event_name || 'Dungeon Master Event';
                    description = payload.description || '';
                    color = '#9b59b6';
                    logType = 'event';
                    
                    // Special handling for specific events
                    if (title.includes('Plague')) {
                        icon = '‚ò†Ô∏è';
                        color = '#e74c3c';
                    } else if (title.includes('Drought')) {
                        icon = 'üåµ';
                        color = '#e67e22';
                    } else if (title.includes('Blight')) {
                        icon = 'üçÇ';
                        color = '#8b4513';
                    } else if (title.includes('Earthquake')) {
                        icon = 'üåç';
                        color = '#7f8c8d';
                    } else if (title.includes('Revolt') || title.includes('Uprising')) {
                        icon = '‚öîÔ∏è';
                        color = '#c0392b';
                    } else if (title.includes('Discovery') || title.includes('Gold')) {
                        icon = '‚ú®';
                        color = '#f1c40f';
                    }
                    break;
                    
                case 'BlightStarted':
                    icon = 'üçÇ';
                    title = 'Blight Outbreak';
                    description = `A blight affects ${payload.affected_resource || 'resources'} in a ${(payload.radius || 0).toFixed(0)}m radius`;
                    color = '#8b4513';
                    logType = 'event';
                    break;
                    
                case 'DroughtStarted':
                    icon = 'üåµ';
                    title = 'Drought Begins';
                    description = `Severe drought in ${payload.region || 'the region'} for ${payload.expected_duration_days || 0} days`;
                    color = '#e67e22';
                    logType = 'event';
                    break;
                    
                case 'WarDeclared':
                    icon = '‚öîÔ∏è';
                    title = 'War Declared!';
                    description = payload.reason || 'Factions go to war';
                    color = '#c0392b';
                    logType = 'combat';
                    break;
                    
                case 'PeaceTreaty':
                    icon = 'üïäÔ∏è';
                    title = 'Peace Treaty';
                    description = payload.terms || 'Factions make peace';
                    color = '#27ae60';
                    logType = 'info';
                    break;
                    
                default:
                    // Generic event
                    description = JSON.stringify(payload).slice(0, 100);
            }
            
            // Show dramatic notification
            showDramaticNotification(icon, title, description, color);
            
            // Log to activity feed
            logActivity(`${icon} ${title}: ${description}`, logType);
        }
        
        // Update connection status indicator
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');
            if (connected) {
                statusEl.textContent = '‚óè Connected';
                statusEl.className = 'connected';
            } else {
                statusEl.textContent = '‚óè Disconnected';
                statusEl.className = 'disconnected';
            }
        }
        
        // Update agents in the scene
        function updateAgents(agentData) {
            const currentAgentIds = new Set();
            
            // Count states and factions
            const stateCounts = {
                'Idle': 0, 'Moving': 0, 'Working': 0,
                'Eating': 0, 'Sleeping': 0, 'Fighting': 0
            };
            let factionACoun = 0, factionBCount = 0;
            
            agentData.forEach(agentInfo => {
                currentAgentIds.add(agentInfo.id);
                
                // Count states
                if (stateCounts[agentInfo.state] !== undefined) {
                    stateCounts[agentInfo.state]++;
                }
                
                // Count factions (simplified check)
                if (agentInfo.faction && agentInfo.faction.includes('Kingdom')) {
                    if (Math.random() > 0.5) { // Simplified faction detection
                        factionACount++;
                    } else {
                        factionBCount++;
                    }
                }
                
                if (!agents.has(agentInfo.id)) {
                    // Always use state-based color by default
                    const state = agentInfo.state || 'Idle';
                    const color = new THREE.Color(STATE_COLORS[state] || STATE_COLORS['Idle']);
                    
                    // Create agent as a Group for easier hovering
                    const agentGroup = new THREE.Group();
                    
                    // Agent body (capsule)
                    const geometry = new THREE.CapsuleGeometry(0.5, 1.5, 8, 16);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.6,
                        metalness: 0.4,
                        emissive: color,
                        emissiveIntensity: 0.2
                    });
                    const body = new THREE.Mesh(geometry, material);
                    body.castShadow = true;
                    body.receiveShadow = true;
                    agentGroup.add(body);
                    
                    // Add a little glow sphere on top (head indicator)
                    const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const headMaterial = new THREE.MeshBasicMaterial({ 
                        color: color,
                        opacity: 0.8,
                        transparent: true
                    });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.y = 1.5;
                    agentGroup.add(head);
                    
                    // Add invisible collision box for easier hovering (covers full body + head)
                    const collisionBox = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 3, 1.5),
                        new THREE.MeshBasicMaterial({ visible: false })
                    );
                    collisionBox.position.y = 0.75; // Center of agent
                    agentGroup.add(collisionBox);
                    
                    scene.add(agentGroup);
                    
                    // Only show birth notification if this is a NEW agent (not initial load)
                    if (!isInitialLoad && !knownAgentIds.has(agentInfo.id)) {
                        showNotification('üë∂ Agent Born', agentInfo.name);
                        logActivity(`üë∂ ${agentInfo.name} was born`, 'birth');
                    }
                    
                    knownAgentIds.add(agentInfo.id);
                    
                    agents.set(agentInfo.id, {
                        mesh: agentGroup,
                        body: body,
                        head: head,
                        targetPos: new THREE.Vector3(agentInfo.x, agentInfo.y + 1, agentInfo.z),
                        name: agentInfo.name,
                        state: agentInfo.state || 'Idle',
                        faction: agentInfo.faction,
                        agentData: agentInfo
                    });
                } else {
                    // Update target position and state color
                    const agent = agents.get(agentInfo.id);
                    agent.targetPos.set(agentInfo.x, agentInfo.y + 1, agentInfo.z);
                    
                    // Update state and add combat effects
                    const newState = agentInfo.state || 'Idle';
                    if (agent.state !== newState) {
                        agent.state = newState;
                        
                        // Combat flash effect
                        if (newState === 'Fighting') {
                            agent.body.material.emissiveIntensity = 0.8;
                            
                            // Add red glow for fighting
                            const combatColor = new THREE.Color(0xff0000);
                            agent.body.material.emissive = combatColor;
                            
                            // Add combat visual indicators
                            addCombatIndicators(agent);
                            
                            // Create spark particles
                            createCombatEffect(agent.mesh.position);
                            logActivity(`‚öîÔ∏è ${agent.name} is fighting!`, 'combat');
                        } else if (agent.state === 'Fighting' && newState !== 'Fighting') {
                            // Combat ended
                            removeCombatIndicators(agent);
                            logActivity(`‚úÖ ${agent.name} stopped fighting`, 'info');
                        }
                        
                        if (newState !== 'Fighting') {
                            // Return to normal state color
                            agent.body.material.emissiveIntensity = 0.2;
                            const stateColor = new THREE.Color(STATE_COLORS[newState] || STATE_COLORS['Idle']);
                            agent.body.material.emissive = stateColor;
                            agent.body.material.color = stateColor;
                            agent.head.material.color = stateColor;
                        }
                    }
                    
                    // Store updated data for tooltip
                    agent.agentData = agentInfo;
                }
            });
            
            // Update legend counts
            document.getElementById('count-idle').textContent = stateCounts['Idle'];
            document.getElementById('count-moving').textContent = stateCounts['Moving'];
            document.getElementById('count-working').textContent = stateCounts['Working'];
            document.getElementById('count-eating').textContent = stateCounts['Eating'];
            document.getElementById('count-sleeping').textContent = stateCounts['Sleeping'];
            document.getElementById('count-fighting').textContent = stateCounts['Fighting'];
            
            // Update faction counts (rough estimate - needs proper faction tracking)
            document.getElementById('faction-a-count').textContent = `${Math.floor(agentData.length / 2)} agents`;
            document.getElementById('faction-b-count').textContent = `${Math.ceil(agentData.length / 2)} agents`;
            
            // Calculate casualties
            const casualties = initialAgentCount - agentData.length;
            document.getElementById('casualties').textContent = casualties;
            
            // After first update, mark as no longer initial load
            if (isInitialLoad && agentData.length > 0) {
                isInitialLoad = false;
                logActivity('üåç World simulation loaded', 'info');
                logActivity(`‚öîÔ∏è War: Kingdom A vs Kingdom B`, 'combat');
            }
            
            // Remove agents that no longer exist (died)
            agents.forEach((agent, id) => {
                if (!currentAgentIds.has(id)) {
                    // Death animation - dramatic!
                    showNotification('üíÄ Agent Died', agent.name);
                    logActivity(`üíÄ ${agent.name} has died`, 'death');
                    
                    // Remove combat indicators if present
                    removeCombatIndicators(agent);
                    
                    // Create headstone/grave marker at death location
                    createHeadstone(agent.mesh.position, agent.name);
                    
                    // Explosion effect
                    createDeathEffect(agent.mesh.position);
                    
                    // Fade and shrink
                    const fadeOut = () => {
                        agent.mesh.scale.multiplyScalar(0.95);
                        agent.body.material.opacity -= 0.05;
                        agent.head.material.opacity -= 0.05;
                        if (agent.body.material.opacity > 0) {
                            requestAnimationFrame(fadeOut);
                        } else {
                            scene.remove(agent.mesh);
                        }
                    };
                    agent.body.material.transparent = true;
                    agent.head.material.transparent = true;
                    fadeOut();
                    agents.delete(id);
                }
            });
        }
        
        // Update resources in the scene
        function updateResources(resourceData) {
            const currentResourceIds = new Set();
            
            // Count resource types
            const resourceCounts = { tree: 0, rock: 0, farm: 0, iron: 0 };
            
            resourceData.forEach(resourceInfo => {
                currentResourceIds.add(resourceInfo.id);
                
                // Count resources
                if (resourceCounts[resourceInfo.resource_type] !== undefined) {
                    resourceCounts[resourceInfo.resource_type]++;
                }
                
                if (!resources.has(resourceInfo.id)) {
                    // Create new resource - all resources are now Groups with collision boxes
                    let visualMesh;
                    let containerGroup = new THREE.Group();
                    
                    switch(resourceInfo.resource_type) {
                        case 'tree':
                            // Tree trunk
                            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 5, 8);
                            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x3a2814 });
                            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                            trunk.castShadow = true;
                            
                            // Tree canopy
                            const canopyGeometry = new THREE.SphereGeometry(2, 8, 8);
                            const canopyMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5016 });
                            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                            canopy.position.y = 4;
                            canopy.castShadow = true;
                            
                            containerGroup.add(trunk);
                            containerGroup.add(canopy);
                            
                            // Add invisible collision box for easier hover
                            const treeCollisionBox = new THREE.Mesh(
                                new THREE.BoxGeometry(4, 8, 4),
                                new THREE.MeshBasicMaterial({ visible: false })
                            );
                            treeCollisionBox.position.y = 2.5;
                            containerGroup.add(treeCollisionBox);
                            break;
                            
                        case 'rock':
                            // Rock visual
                            const rockGeometry = new THREE.DodecahedronGeometry(1.5, 0);
                            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
                            visualMesh = new THREE.Mesh(rockGeometry, rockMaterial);
                            visualMesh.castShadow = true;
                            containerGroup.add(visualMesh);
                            
                            // Add larger invisible collision box
                            const rockCollisionBox = new THREE.Mesh(
                                new THREE.BoxGeometry(4, 4, 4),
                                new THREE.MeshBasicMaterial({ visible: false })
                            );
                            rockCollisionBox.position.y = 1;
                            containerGroup.add(rockCollisionBox);
                            break;
                            
                        case 'farm':
                            // Farm plot visual
                            const farmGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                            const farmMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                            visualMesh = new THREE.Mesh(farmGeometry, farmMaterial);
                            visualMesh.receiveShadow = true;
                            containerGroup.add(visualMesh);
                            
                            // Add taller invisible collision box for easier hover
                            const farmCollisionBox = new THREE.Mesh(
                                new THREE.BoxGeometry(4, 3, 4),
                                new THREE.MeshBasicMaterial({ visible: false })
                            );
                            farmCollisionBox.position.y = 1.5;
                            containerGroup.add(farmCollisionBox);
                            break;
                            
                        case 'iron':
                            // Iron deposit visual
                            const ironGeometry = new THREE.OctahedronGeometry(1.2);
                            const ironMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x708090, 
                                metalness: 0.8,
                                roughness: 0.3
                            });
                            visualMesh = new THREE.Mesh(ironGeometry, ironMaterial);
                            visualMesh.castShadow = true;
                            containerGroup.add(visualMesh);
                            
                            // Add larger invisible collision box
                            const ironCollisionBox = new THREE.Mesh(
                                new THREE.BoxGeometry(4, 4, 4),
                                new THREE.MeshBasicMaterial({ visible: false })
                            );
                            ironCollisionBox.position.y = 1;
                            containerGroup.add(ironCollisionBox);
                            break;
                    }
                    
                    containerGroup.position.set(resourceInfo.x, resourceInfo.y, resourceInfo.z);
                    scene.add(containerGroup);
                    
                    resources.set(resourceInfo.id, {
                        mesh: containerGroup,
                        type: resourceInfo.resource_type,
                        data: resourceInfo
                    });
                }
            });
            
            // Remove depleted resources
            resources.forEach((resource, id) => {
                if (!currentResourceIds.has(id)) {
                    scene.remove(resource.mesh);
                    resources.delete(id);
                }
            });
            
            // Update resource counts in UI
            document.getElementById('resource-tree').textContent = resourceCounts.tree;
            document.getElementById('resource-rock').textContent = resourceCounts.rock;
            document.getElementById('resource-farm').textContent = resourceCounts.farm;
            document.getElementById('resource-iron').textContent = resourceCounts.iron;
        }
        
        // Animation loop
        let lastTime = Date.now();
        let frameCount = 0;
        let fps = 60;
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (!isPaused) {
                const time = Date.now() * 0.001;
                
                // Smooth agent movement with faster interpolation
                agents.forEach(agent => {
                    agent.mesh.position.lerp(agent.targetPos, 0.3); // Increased from 0.1 for snappier movement
                    
                    // Add subtle bobbing animation (breathing effect)
                    agent.mesh.position.y += Math.sin(time * 2 + agent.mesh.position.x) * 0.005;
                    
                    // Faster rotation for more active appearance
                    agent.mesh.rotation.y += 0.02; // Doubled from 0.01
                    
                    // Animate combat indicators if fighting
                    if (agent.combatIndicators) {
                        // Pulse the red ring
                        const pulseScale = 1 + Math.sin(time * 5) * 0.2; // Fast pulse
                        agent.combatIndicators.ring.scale.set(pulseScale, pulseScale, 1);
                        
                        // Pulse opacity
                        agent.combatIndicators.ring.material.opacity = 0.4 + Math.sin(time * 4) * 0.3;
                        
                        // Bounce the crossed swords icon
                        agent.combatIndicators.swordSprite.position.y = 3 + Math.sin(time * 3) * 0.3;
                        
                        // Rotate the swords slightly
                        agent.combatIndicators.swordSprite.material.rotation = Math.sin(time * 2) * 0.2;
                        
                        // Pulse the body glow for fighting agents
                        agent.body.material.emissiveIntensity = 0.6 + Math.sin(time * 6) * 0.3;
                    }
                });
                
                // Animate and clean up headstones
                const currentTime = Date.now();
                for (let i = headstones.length - 1; i >= 0; i--) {
                    const headstone = headstones[i];
                    const age = currentTime - headstone.createdAt;
                    
                    if (age > headstone.lifetime && !headstone.fadeStarted) {
                        // Start sinking after lifetime
                        headstone.fadeStarted = true;
                    }
                    
                    if (headstone.fadeStarted) {
                        // Slowly sink into ground
                        headstone.group.position.y -= 0.01;
                        
                        // Fade out opacity
                        headstone.group.children.forEach(child => {
                            if (child.material) {
                                if (!child.material.transparent) {
                                    child.material.transparent = true;
                                }
                                child.material.opacity = Math.max(0, child.material.opacity - 0.01);
                            }
                        });
                        
                        // Remove when fully sunk
                        if (headstone.group.position.y < -2) {
                            scene.remove(headstone.group);
                            headstones.splice(i, 1);
                        }
                    }
                }
                
                controls.update();
                renderer.render(scene, camera);
            }
            
            // Calculate FPS
            frameCount++;
            const currentTime = Date.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Mouse movement for tooltips
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check for agent intersections first
            const agentMeshes = Array.from(agents.values()).map(a => a.mesh);
            const agentIntersects = raycaster.intersectObjects(agentMeshes, true);
            
            if (agentIntersects.length > 0) {
                const hoveredMesh = agentIntersects[0].object.parent || agentIntersects[0].object;
                
                // Find which agent this mesh belongs to
                for (const [id, agent] of agents) {
                    if (agent.mesh === hoveredMesh) {
                        showAgentTooltip(agent, event.clientX, event.clientY);
                        return;
                    }
                }
            }
            
            // Check for resource intersections
            const resourceMeshes = Array.from(resources.values()).map(r => r.mesh);
            const resourceIntersects = raycaster.intersectObjects(resourceMeshes, true);
            
            if (resourceIntersects.length > 0) {
                const hoveredMesh = resourceIntersects[0].object.parent || resourceIntersects[0].object;
                
                // Find which resource this mesh belongs to
                for (const [id, resource] of resources) {
                    if (resource.mesh === hoveredMesh) {
                        showResourceTooltip(resource, event.clientX, event.clientY);
                        return;
                    }
                }
            }
            
            hideTooltip();
        }
        
        function onClick(event) {
            // Could add click interactions here
        }
        
        // Show tooltip for agent
        function showAgentTooltip(agent, x, y) {
            const tooltip = document.getElementById('tooltip');
            const data = agent.agentData || {};
            
            tooltip.innerHTML = `
                <h4>${agent.name}</h4>
                <div class="tooltip-row">
                    <span class="tooltip-label">State:</span>
                    <span class="tooltip-value">${agent.state}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Faction:</span>
                    <span class="tooltip-value">${agent.faction ? '‚öîÔ∏è At War' : 'None'}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Position:</span>
                    <span class="tooltip-value">
                        ${agent.mesh.position.x.toFixed(1)}, 
                        ${agent.mesh.position.z.toFixed(1)}
                    </span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">ID:</span>
                    <span class="tooltip-value" style="font-size: 9px;">${data.id || 'Unknown'}</span>
                </div>
            `;
            
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.style.display = 'block';
        }
        
        // Show tooltip for resource
        function showResourceTooltip(resource, x, y) {
            const tooltip = document.getElementById('tooltip');
            const data = resource.data || {};
            
            // Resource type icons and names
            const resourceDisplay = {
                'tree': { icon: 'üå≥', name: 'Tree', color: '#2d5016' },
                'rock': { icon: 'ü™®', name: 'Rock', color: '#666666' },
                'farm': { icon: 'üåæ', name: 'Farm', color: '#8b4513' },
                'iron': { icon: '‚õèÔ∏è', name: 'Iron Deposit', color: '#708090' }
            };
            
            const display = resourceDisplay[resource.type] || { icon: '‚ùì', name: resource.type, color: '#888888' };
            
            tooltip.innerHTML = `
                <h4>${display.icon} ${display.name}</h4>
                <div class="tooltip-row">
                    <span class="tooltip-label">Quantity:</span>
                    <span class="tooltip-value">${data.quantity || 0}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Position:</span>
                    <span class="tooltip-value">
                        ${(data.x || 0).toFixed(1)}, 
                        ${(data.z || 0).toFixed(1)}
                    </span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">ID:</span>
                    <span class="tooltip-value" style="font-size: 9px;">${data.id || 'Unknown'}</span>
                </div>
            `;
            
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.style.display = 'block';
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        // Log activity to feed
        function logActivity(message, type) {
            // Deduplicate - don't add if same message exists recently
            if (activityLog.length > 0 && activityLog[0].message === message) {
                return;
            }
            
            const timestamp = new Date().toLocaleTimeString();
            activityLog.unshift({ message, timestamp, type });
            
            // Keep only last 20 items
            if (activityLog.length > 20) {
                activityLog.pop();
            }
            
            // Update display
            const activityList = document.getElementById('activity-list');
            if (activityList) {
                activityList.innerHTML = activityLog.map(item => `
                    <div class="activity-item">
                        <div>${item.message}</div>
                        <div class="activity-time">${item.timestamp}</div>
                    </div>
                `).join('');
            }
        }
        
        // Switch all agents to faction colors
        function showFactionColors() {
            if (showingFactionColors) return;
            showingFactionColors = true;
            
            agents.forEach(agent => {
                // Skip fighting agents (they should stay red)
                if (agent.state === 'Fighting') return;
                
                const agentData = agent.agentData || {};
                if (agentData.faction) {
                    // Determine faction color
                    const factionKey = agentData.faction.includes('2cf7e1d2') ? 'Kingdom A' : 'Kingdom B';
                    const factionColor = new THREE.Color(FACTION_COLORS[factionKey]);
                    
                    agent.body.material.color = factionColor;
                    agent.body.material.emissive = factionColor;
                    agent.head.material.color = factionColor;
                }
            });
        }
        
        // Switch all agents back to state colors
        function showStateColors() {
            if (!showingFactionColors) return;
            showingFactionColors = false;
            
            agents.forEach(agent => {
                // Skip fighting agents (they should stay red)
                if (agent.state === 'Fighting') return;
                
                const state = agent.state || 'Idle';
                const stateColor = new THREE.Color(STATE_COLORS[state] || STATE_COLORS['Idle']);
                
                agent.body.material.color = stateColor;
                agent.body.material.emissive = stateColor;
                agent.head.material.color = stateColor;
            });
        }
        
        // Global functions for UI
        window.resetCamera = function() {
            camera.position.set(70, 60, 70);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        };
        
        window.togglePause = function() {
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');
            btn.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
        };
        
        window.testCombat = function() {
            // Force a few random agents into fighting state for testing
            const agentArray = Array.from(agents.values());
            if (agentArray.length < 2) {
                alert('Need at least 2 agents to test combat!');
                return;
            }
            
            // Pick 3-5 random agents and force them to fight
            const numFighters = Math.min(Math.floor(Math.random() * 3) + 3, agentArray.length);
            const fighters = [];
            
            for (let i = 0; i < numFighters; i++) {
                const randomIndex = Math.floor(Math.random() * agentArray.length);
                fighters.push(agentArray[randomIndex]);
            }
            
            // Set them all to fighting state
            fighters.forEach(agent => {
                agent.state = 'Fighting';
                
                // Change body color to red
                agent.body.material.emissiveIntensity = 0.8;
                agent.body.material.emissive = new THREE.Color(0xff0000);
                
                // Add combat indicators
                addCombatIndicators(agent);
            });
            
            showNotification('‚öîÔ∏è Combat Test', `Forced ${numFighters} agents into combat mode!`);
            logActivity(`‚öîÔ∏è Combat test activated - ${numFighters} agents fighting`, 'combat');
            
            // Automatically remove indicators after 10 seconds
            setTimeout(() => {
                fighters.forEach(agent => {
                    if (agents.has(agent.mesh.uuid)) {
                        removeCombatIndicators(agent);
                        agent.state = 'Idle';
                        agent.body.material.emissiveIntensity = 0.2;
                        
                        // Reset to state color (unless showing faction colors)
                        const stateColor = new THREE.Color(STATE_COLORS['Idle']);
                        agent.body.material.color = stateColor;
                        agent.body.material.emissive = stateColor;
                        agent.head.material.color = stateColor;
                        
                        // Re-apply faction colors if hovering
                        if (showingFactionColors && agent.agentData && agent.agentData.faction) {
                            const factionKey = agent.agentData.faction.includes('2cf7e1d2') ? 'Kingdom A' : 'Kingdom B';
                            const factionColor = new THREE.Color(FACTION_COLORS[factionKey]);
                            agent.body.material.color = factionColor;
                            agent.body.material.emissive = factionColor;
                            agent.head.material.color = factionColor;
                        }
                    }
                });
                showNotification('‚úÖ Combat Test Ended', 'Agents returned to normal');
            }, 10000);
        };
        
        // Show notification toast
        function showNotification(title, body) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `
                <div class="notification-title">${title}</div>
                <div class="notification-body">${body}</div>
            `;
            document.body.appendChild(notification);
            
            // Remove after animation completes
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // Show dramatic event notification (larger, more prominent)
        function showDramaticNotification(icon, title, description, color) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.style.background = `linear-gradient(135deg, ${color}dd, ${color}aa)`;
            notification.style.border = `3px solid ${color}`;
            notification.style.minWidth = '400px';
            notification.style.fontSize = '16px';
            notification.style.boxShadow = `0 8px 32px ${color}88`;
            
            notification.innerHTML = `
                <div style="font-size: 48px; text-align: center; margin-bottom: 10px;">${icon}</div>
                <div class="notification-title" style="font-size: 24px; text-align: center;">${title}</div>
                <div class="notification-body" style="font-size: 14px; text-align: center; margin-top: 8px;">${description}</div>
            `;
            document.body.appendChild(notification);
            
            // Remove after longer duration for dramatic events
            setTimeout(() => {
                notification.remove();
            }, 6000);
        }
        
        // Add combat visual indicators (crossed swords + red ring)
        function addCombatIndicators(agent) {
            // Don't add if already fighting
            if (agent.combatIndicators) return;
            
            // Create crossed swords icon above head
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Draw crossed swords emoji/text
            ctx.font = 'bold 100px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚öîÔ∏è', 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false // Always visible on top
            });
            const swordSprite = new THREE.Sprite(spriteMaterial);
            swordSprite.scale.set(1.5, 1.5, 1);
            swordSprite.position.y = 3; // Above head
            agent.mesh.add(swordSprite);
            
            // Create pulsing red ring on ground
            const ringGeometry = new THREE.RingGeometry(1.2, 1.8, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2; // Lay flat
            ring.position.y = 0.1; // Slightly above ground
            agent.mesh.add(ring);
            
            // Store references for removal and animation
            agent.combatIndicators = {
                swordSprite: swordSprite,
                ring: ring
            };
        }
        
        // Remove combat visual indicators
        function removeCombatIndicators(agent) {
            if (agent.combatIndicators) {
                agent.mesh.remove(agent.combatIndicators.swordSprite);
                agent.mesh.remove(agent.combatIndicators.ring);
                agent.combatIndicators = null;
            }
        }
        
        // Combat particle effect
        function createCombatEffect(position) {
            const particleCount = 20;
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xff6600,
                    transparent: true,
                    opacity: 1.0
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 2,
                    (Math.random() - 0.5) * 2
                );
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Animate particles
            let life = 0;
            const animateParticles = () => {
                life += 0.05;
                particles.children.forEach(p => {
                    p.position.add(p.velocity);
                    p.velocity.y -= 0.05; // Gravity
                    p.material.opacity = 1.0 - life;
                });
                
                if (life < 1.0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                }
            };
            animateParticles();
        }
        
        // Create headstone/grave marker at death location
        function createHeadstone(position, agentName) {
            const headstoneGroup = new THREE.Group();
            
            // Grave base (dark mound)
            const moundGeometry = new THREE.CylinderGeometry(1.2, 1.5, 0.3, 8);
            const moundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2d1810,
                roughness: 0.9
            });
            const mound = new THREE.Mesh(moundGeometry, moundMaterial);
            mound.position.y = 0.15;
            headstoneGroup.add(mound);
            
            // Headstone (vertical stone)
            const stoneGeometry = new THREE.BoxGeometry(1.2, 1.5, 0.2);
            const stoneMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a4a4a,
                roughness: 0.8
            });
            const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
            stone.position.y = 1.0;
            stone.castShadow = true;
            headstoneGroup.add(stone);
            
            // Skull emoji on headstone
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üíÄ', 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const skullSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            }));
            skullSprite.scale.set(0.8, 0.8, 1);
            skullSprite.position.set(0, 1.2, 0.15);
            headstoneGroup.add(skullSprite);
            
            // Name label (floating text above)
            const nameCanvas = document.createElement('canvas');
            nameCanvas.width = 256;
            nameCanvas.height = 64;
            const nameCtx = nameCanvas.getContext('2d');
            nameCtx.fillStyle = 'white';
            nameCtx.strokeStyle = 'black';
            nameCtx.lineWidth = 3;
            nameCtx.font = 'bold 32px Arial';
            nameCtx.textAlign = 'center';
            nameCtx.textBaseline = 'middle';
            nameCtx.strokeText(agentName, 128, 32);
            nameCtx.fillText(agentName, 128, 32);
            
            const nameTexture = new THREE.CanvasTexture(nameCanvas);
            const nameSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                map: nameTexture,
                transparent: true
            }));
            nameSprite.scale.set(3, 0.75, 1);
            nameSprite.position.set(0, 2.2, 0);
            headstoneGroup.add(nameSprite);
            
            // Add cross on top
            const crossVertical = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.5, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x8b7355 })
            );
            crossVertical.position.set(0, 2.0, 0);
            headstoneGroup.add(crossVertical);
            
            const crossHorizontal = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.1, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x8b7355 })
            );
            crossHorizontal.position.set(0, 1.9, 0);
            headstoneGroup.add(crossHorizontal);
            
            // Position at death location
            headstoneGroup.position.copy(position);
            headstoneGroup.position.y = 0;
            
            scene.add(headstoneGroup);
            
            // Store headstone data for later removal/animation
            const headstoneData = {
                group: headstoneGroup,
                createdAt: Date.now(),
                lifetime: 45000, // 45 seconds before starting to sink
                fadeStarted: false
            };
            headstones.push(headstoneData);
        }
        
        // Death explosion effect
        function createDeathEffect(position) {
            const particleCount = 30;
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.15, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x888888,
                    transparent: true,
                    opacity: 1.0
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    Math.random() * 3 + 1,
                    (Math.random() - 0.5) * 3
                );
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Animate explosion
            let life = 0;
            const animateExplosion = () => {
                life += 0.03;
                particles.children.forEach(p => {
                    p.position.add(p.velocity);
                    p.velocity.y -= 0.08; // Gravity
                    p.material.opacity = 1.0 - life;
                });
                
                if (life < 1.0) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(particles);
                }
            };
            animateExplosion();
        }
        
        // Start the visualizer
        init();
        
        console.log('üåç World Simulation Visualizer Started');
        console.log('API: ' + API_URL);
        console.log('State Colors:', STATE_COLORS);
    </script>
</body>
</html>

