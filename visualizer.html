<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç World Simulation Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a1a;
            color: #eee;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            min-width: 250px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #stats h2 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 20px;
            font-weight: 600;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 12px 0;
            font-size: 14px;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            color: #fff;
            font-weight: bold;
            font-size: 16px;
        }
        
        #connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }
        
        .connected {
            background: rgba(76, 175, 80, 0.9);
            border: 2px solid #4caf50;
        }
        
        .disconnected {
            background: rgba(244, 67, 54, 0.9);
            border: 2px solid #f44336;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        #controls button {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            border: none;
            color: #fff;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.3);
        }
        
        #controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.5);
        }
        
        #controls button:active {
            transform: translateY(0);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            color: #4ecdc4;
            text-align: center;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(78, 205, 196, 0.2);
            border-top-color: #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            font-size: 12px;
            color: #aaa;
            max-width: 200px;
        }
        
        #legend {
            position: absolute;
            top: 200px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 200px;
        }
        
        #legend h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 16px;
            font-weight: 600;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            font-size: 13px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .legend-label {
            color: #ddd;
            flex: 1;
        }
        
        .legend-count {
            color: #4ecdc4;
            font-weight: bold;
            margin-left: 10px;
        }
        
        #faction-stats {
            position: absolute;
            top: 430px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 250px;
        }
        
        #faction-stats h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 16px;
            font-weight: 600;
        }
        
        .faction-item {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }
        
        .faction-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .faction-count {
            font-size: 12px;
            color: #aaa;
        }
        
        #resource-stats {
            position: absolute;
            top: 620px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 250px;
        }
        
        #resource-stats h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            font-size: 16px;
            font-weight: 600;
        }
        
        .resource-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 13px;
        }
        
        .resource-icon {
            margin-right: 8px;
        }
        
        #activity-feed {
            position: absolute;
            bottom: 120px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            max-width: 300px;
            max-height: 250px;
            overflow-y: auto;
        }
        
        #activity-feed h3 {
            margin-bottom: 10px;
            color: #4ecdc4;
            font-size: 14px;
            font-weight: 600;
        }
        
        .activity-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 11px;
            color: #ccc;
            border-left: 3px solid #4ecdc4;
        }
        
        .activity-time {
            color: #888;
            font-size: 10px;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            pointer-events: none;
            display: none;
            z-index: 2000;
            border: 2px solid #4ecdc4;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
            max-width: 300px;
        }
        
        #tooltip h4 {
            margin-bottom: 10px;
            color: #4ecdc4;
            font-size: 16px;
        }
        
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .tooltip-label {
            color: #aaa;
        }
        
        .tooltip-value {
            color: #fff;
            font-weight: bold;
        }
        
        .notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            border-left: 4px solid #4ecdc4;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease, slideOut 0.3s ease 2.7s;
            z-index: 1000;
            max-width: 300px;
        }
        
        .notification-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .notification-body {
            font-size: 12px;
            color: #ccc;
        }
        
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="stats">
        <h2>üìä Simulation Stats</h2>
        <div class="stat-item">
            <span class="stat-label">üßë Agents:</span>
            <span class="stat-value" id="agent-count">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">‚è±Ô∏è Uptime:</span>
            <span class="stat-value" id="uptime">0s</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">üì° Events:</span>
            <span class="stat-value" id="events">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">üéÆ FPS:</span>
            <span class="stat-value" id="fps">60</span>
        </div>
    </div>
    
    <div id="legend">
        <h3>üé® Agent States</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #4ecdc4;"></div>
            <span class="legend-label">Idle</span>
            <span class="legend-count" id="count-idle">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #95e1d3;"></div>
            <span class="legend-label">Moving</span>
            <span class="legend-count" id="count-moving">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b6b;"></div>
            <span class="legend-label">üî® Working</span>
            <span class="legend-count" id="count-working">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffd93d;"></div>
            <span class="legend-label">üçû Eating</span>
            <span class="legend-count" id="count-eating">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #9b59b6;"></div>
            <span class="legend-label">üí§ Sleeping</span>
            <span class="legend-count" id="count-sleeping">0</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #e74c3c;"></div>
            <span class="legend-label">‚öîÔ∏è Fighting</span>
            <span class="legend-count" id="count-fighting">0</span>
        </div>
    </div>
    
    <div id="faction-stats">
        <h3>‚öîÔ∏è Faction Status</h3>
        <div class="faction-item">
            <div class="faction-name" style="color: #3498db;">üîµ Kingdom A</div>
            <div class="faction-count" id="faction-a-count">0 agents</div>
        </div>
        <div class="faction-item">
            <div class="faction-name" style="color: #e74c3c;">üî¥ Kingdom B</div>
            <div class="faction-count" id="faction-b-count">0 agents</div>
        </div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
            <div class="faction-count">
                <span style="color: #ff6b6b;">üíÄ War Casualties:</span>
                <span id="casualties" style="color: #fff; font-weight: bold;">0</span>
            </div>
        </div>
    </div>
    
    <div id="resource-stats">
        <h3>üè≠ Resources</h3>
        <div class="resource-row">
            <span><span class="resource-icon">üå≤</span>Trees:</span>
            <span id="resource-tree" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
        <div class="resource-row">
            <span><span class="resource-icon">‚õ∞Ô∏è</span>Rocks:</span>
            <span id="resource-rock" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
        <div class="resource-row">
            <span><span class="resource-icon">üåæ</span>Farms:</span>
            <span id="resource-farm" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
        <div class="resource-row">
            <span><span class="resource-icon">‚öôÔ∏è</span>Iron:</span>
            <span id="resource-iron" style="color: #4ecdc4; font-weight: bold;">0</span>
        </div>
    </div>
    
    <div id="activity-feed">
        <h3>üì° Live Activity</h3>
        <div id="activity-list"></div>
    </div>
    
    <div id="tooltip"></div>
    
    <div id="connection-status" class="disconnected">‚óè Connecting...</div>
    
    <div id="controls">
        <button onclick="resetCamera()">üé• Reset Camera</button>
        <button onclick="togglePause()" id="pauseBtn">‚è∏Ô∏è Pause</button>
    </div>
    
    <div id="info">
        <strong>üïπÔ∏è Controls:</strong><br>
        Left Mouse: Rotate<br>
        Right Mouse: Pan<br>
        Scroll: Zoom
    </div>
    
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        Loading Three.js...
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        const API_URL = 'http://127.0.0.1:8080';
        let scene, camera, renderer, controls;
        let agents = new Map();
        let resources = new Map();
        let isPaused = false;
        let terrainMesh;
        let lastEventCount = 0;
        let initialAgentCount = 100;
        let activityLog = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isInitialLoad = true;
        let knownAgentIds = new Set();
        
        // State-based colors
        const STATE_COLORS = {
            'Idle': 0x4ecdc4,      // Cyan
            'Moving': 0x95e1d3,    // Light cyan  
            'Working': 0xff6b6b,   // Red
            'Eating': 0xffd93d,    // Yellow
            'Sleeping': 0x9b59b6,  // Purple
            'Fighting': 0xe74c3c,  // Dark red
            'Dead': 0x555555       // Gray
        };
        
        // Faction colors (for team identification)
        const FACTION_COLORS = {
            'Kingdom A': 0x3498db,  // Blue team
            'Kingdom B': 0xe74c3c,  // Red team
        };
        
        // Initialize Three.js scene
        function init() {
            document.getElementById('loading').style.display = 'none';
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.Fog(0x0a0a1a, 150, 400);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(70, 60, 70);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 200;
            controls.maxPolarAngle = Math.PI / 2.1;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0x404060, 1.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(80, 120, 60);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // Hemisphere light for ambient atmosphere
            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x6b8e23, 0.5);
            scene.add(hemiLight);
            
            // Grid helper
            const gridHelper = new THREE.GridHelper(200, 40, 0x4ecdc4, 0x2a2a3e);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
            
            // Terrain plane
            const terrainGeometry = new THREE.PlaneGeometry(200, 200, 20, 20);
            const terrainMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a4d2e,
                roughness: 0.9,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            terrainMesh = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrainMesh.rotation.x = -Math.PI / 2;
            terrainMesh.receiveShadow = true;
            terrainMesh.position.y = 0;
            scene.add(terrainMesh);
            
            // Resources will be added dynamically from API
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Handle mouse movement for tooltips
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onClick);
            
            // Start animation loop
            animate();
            
            // Start fetching data
            fetchWorldState();
            setInterval(fetchWorldState, 200); // Update every 0.2 seconds for smoother movement (was 500ms)
            fetchMetrics();
            setInterval(fetchMetrics, 1000);
        }
        
        
        // Fetch world state from API
        async function fetchWorldState() {
            try {
                const response = await fetch(`${API_URL}/api/world/state`);
                if (!response.ok) {
                    throw new Error('API returned ' + response.status);
                }
                const data = await response.json();
                
                // Check if we got valid data
                if (data && data.agents) {
                    updateConnectionStatus(true);
                    updateAgents(data.agents);
                    updateResources(data.resources || []);
                } else {
                    console.warn('Invalid data received:', data);
                    updateConnectionStatus(false);
                }
            } catch (error) {
                console.error('Error fetching world state:', error);
                updateConnectionStatus(false);
            }
        }
        
        // Fetch metrics from API
        async function fetchMetrics() {
            try {
                const response = await fetch(`${API_URL}/api/metrics`);
                if (!response.ok) throw new Error('API returned ' + response.status);
                const data = await response.json();
                
                document.getElementById('agent-count').textContent = data.agent_count || 0;
                document.getElementById('uptime').textContent = `${data.uptime_seconds || 0}s`;
                document.getElementById('events').textContent = data.events_processed || 0;
                
                // Check for new events
                if (data.events_processed > lastEventCount && lastEventCount > 0) {
                    showNotification('üì° New Event', 'Simulation event occurred');
                    logActivity('üì° Simulation event triggered', 'event');
                }
                lastEventCount = data.events_processed;
            } catch (error) {
                console.error('Error fetching metrics:', error);
            }
        }
        
        // Update connection status indicator
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');
            if (connected) {
                statusEl.textContent = '‚óè Connected';
                statusEl.className = 'connected';
            } else {
                statusEl.textContent = '‚óè Disconnected';
                statusEl.className = 'disconnected';
            }
        }
        
        // Update agents in the scene
        function updateAgents(agentData) {
            const currentAgentIds = new Set();
            
            // Count states and factions
            const stateCounts = {
                'Idle': 0, 'Moving': 0, 'Working': 0,
                'Eating': 0, 'Sleeping': 0, 'Fighting': 0
            };
            let factionACoun = 0, factionBCount = 0;
            
            agentData.forEach(agentInfo => {
                currentAgentIds.add(agentInfo.id);
                
                // Count states
                if (stateCounts[agentInfo.state] !== undefined) {
                    stateCounts[agentInfo.state]++;
                }
                
                // Count factions (simplified check)
                if (agentInfo.faction && agentInfo.faction.includes('Kingdom')) {
                    if (Math.random() > 0.5) { // Simplified faction detection
                        factionACount++;
                    } else {
                        factionBCount++;
                    }
                }
                
                if (!agents.has(agentInfo.id)) {
                    // Create new agent with faction-based color (if in faction) or state color
                    let color;
                    if (agentInfo.faction) {
                        // Use faction color for team identification
                        const factionKey = agentInfo.faction.includes('FactionId') ? 
                            (agentInfo.faction.includes('Kingdom A') || Math.random() > 0.5 ? 'Kingdom A' : 'Kingdom B') :
                            'Kingdom A';
                        color = new THREE.Color(FACTION_COLORS[factionKey] || FACTION_COLORS['Kingdom A']);
                    } else {
                        const state = agentInfo.state || 'Idle';
                        color = new THREE.Color(STATE_COLORS[state] || STATE_COLORS['Idle']);
                    }
                    
                    const geometry = new THREE.CapsuleGeometry(0.5, 1.5, 8, 16);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.6,
                        metalness: 0.4,
                        emissive: color,
                        emissiveIntensity: 0.2
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    
                    // Add a little glow sphere on top (head indicator)
                    const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const headMaterial = new THREE.MeshBasicMaterial({ 
                        color: color,
                        opacity: 0.8,
                        transparent: true
                    });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.y = 1.5;
                    mesh.add(head);
                    
                    scene.add(mesh);
                    
                    // Only show birth notification if this is a NEW agent (not initial load)
                    if (!isInitialLoad && !knownAgentIds.has(agentInfo.id)) {
                        showNotification('üë∂ Agent Born', agentInfo.name);
                        logActivity(`üë∂ ${agentInfo.name} was born`, 'birth');
                    }
                    
                    knownAgentIds.add(agentInfo.id);
                    
                    agents.set(agentInfo.id, {
                        mesh: mesh,
                        head: head,
                        targetPos: new THREE.Vector3(agentInfo.x, agentInfo.y + 1, agentInfo.z),
                        name: agentInfo.name,
                        state: agentInfo.state || 'Idle',
                        faction: agentInfo.faction,
                        agentData: agentInfo
                    });
                } else {
                    // Update target position and state color
                    const agent = agents.get(agentInfo.id);
                    agent.targetPos.set(agentInfo.x, agentInfo.y + 1, agentInfo.z);
                    
                    // Update state and add combat effects
                    const newState = agentInfo.state || 'Idle';
                    if (agent.state !== newState) {
                        agent.state = newState;
                        
                        // Combat flash effect
                        if (newState === 'Fighting') {
                            agent.mesh.material.emissiveIntensity = 0.8;
                            
                            // Add red glow for fighting
                            const combatColor = new THREE.Color(0xff0000);
                            agent.mesh.material.emissive = combatColor;
                            
                            // Create spark particles
                            createCombatEffect(agent.mesh.position);
                            logActivity(`‚öîÔ∏è ${agent.name} is fighting!`, 'combat');
                        } else if (agent.state === 'Fighting' && newState !== 'Fighting') {
                            // Combat ended
                            logActivity(`‚úÖ ${agent.name} stopped fighting`, 'info');
                        }
                        
                        if (newState !== 'Fighting') {
                            // Return to normal
                            agent.mesh.material.emissiveIntensity = 0.2;
                            
                            // Base faction color or state color
                            if (agentInfo.faction) {
                                const factionKey = 'Kingdom A'; // Simplified
                                const baseColor = new THREE.Color(FACTION_COLORS[factionKey] || FACTION_COLORS['Kingdom A']);
                                agent.mesh.material.emissive = baseColor;
                            }
                        }
                    }
                    
                    // Store updated data for tooltip
                    agent.agentData = agentInfo;
                }
            });
            
            // Update legend counts
            document.getElementById('count-idle').textContent = stateCounts['Idle'];
            document.getElementById('count-moving').textContent = stateCounts['Moving'];
            document.getElementById('count-working').textContent = stateCounts['Working'];
            document.getElementById('count-eating').textContent = stateCounts['Eating'];
            document.getElementById('count-sleeping').textContent = stateCounts['Sleeping'];
            document.getElementById('count-fighting').textContent = stateCounts['Fighting'];
            
            // Update faction counts (rough estimate - needs proper faction tracking)
            document.getElementById('faction-a-count').textContent = `${Math.floor(agentData.length / 2)} agents`;
            document.getElementById('faction-b-count').textContent = `${Math.ceil(agentData.length / 2)} agents`;
            
            // Calculate casualties
            const casualties = initialAgentCount - agentData.length;
            document.getElementById('casualties').textContent = casualties;
            
            // After first update, mark as no longer initial load
            if (isInitialLoad && agentData.length > 0) {
                isInitialLoad = false;
                logActivity('üåç World simulation loaded', 'info');
                logActivity(`‚öîÔ∏è War: Kingdom A vs Kingdom B`, 'combat');
            }
            
            // Remove agents that no longer exist (died)
            agents.forEach((agent, id) => {
                if (!currentAgentIds.has(id)) {
                    // Death animation - dramatic!
                    showNotification('üíÄ Agent Died', agent.name);
                    logActivity(`üíÄ ${agent.name} has died`, 'death');
                    
                    // Explosion effect
                    createDeathEffect(agent.mesh.position);
                    
                    // Fade and shrink
                    const fadeOut = () => {
                        agent.mesh.scale.multiplyScalar(0.95);
                        agent.mesh.material.opacity -= 0.05;
                        if (agent.mesh.material.opacity > 0) {
                            requestAnimationFrame(fadeOut);
                        } else {
                            scene.remove(agent.mesh);
                        }
                    };
                    agent.mesh.material.transparent = true;
                    fadeOut();
                    agents.delete(id);
                }
            });
        }
        
        // Update resources in the scene
        function updateResources(resourceData) {
            const currentResourceIds = new Set();
            
            // Count resource types
            const resourceCounts = { tree: 0, rock: 0, farm: 0, iron: 0 };
            
            resourceData.forEach(resourceInfo => {
                currentResourceIds.add(resourceInfo.id);
                
                // Count resources
                if (resourceCounts[resourceInfo.resource_type] !== undefined) {
                    resourceCounts[resourceInfo.resource_type]++;
                }
                
                if (!resources.has(resourceInfo.id)) {
                    // Create new resource
                    let mesh;
                    
                    switch(resourceInfo.resource_type) {
                        case 'tree':
                            // Tree trunk
                            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 5, 8);
                            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x3a2814 });
                            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                            trunk.castShadow = true;
                            
                            // Tree canopy
                            const canopyGeometry = new THREE.SphereGeometry(2, 8, 8);
                            const canopyMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5016 });
                            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                            canopy.position.y = 4;
                            canopy.castShadow = true;
                            
                            mesh = new THREE.Group();
                            mesh.add(trunk);
                            mesh.add(canopy);
                            break;
                            
                        case 'rock':
                            // Rock
                            const rockGeometry = new THREE.DodecahedronGeometry(1.5, 0);
                            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
                            mesh = new THREE.Mesh(rockGeometry, rockMaterial);
                            mesh.castShadow = true;
                            break;
                            
                        case 'farm':
                            // Farm plot
                            const farmGeometry = new THREE.BoxGeometry(3, 0.3, 3);
                            const farmMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                            mesh = new THREE.Mesh(farmGeometry, farmMaterial);
                            mesh.receiveShadow = true;
                            break;
                            
                        case 'iron':
                            // Iron deposit
                            const ironGeometry = new THREE.OctahedronGeometry(1.2);
                            const ironMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x708090, 
                                metalness: 0.8,
                                roughness: 0.3
                            });
                            mesh = new THREE.Mesh(ironGeometry, ironMaterial);
                            mesh.castShadow = true;
                            break;
                    }
                    
                    mesh.position.set(resourceInfo.x, resourceInfo.y, resourceInfo.z);
                    scene.add(mesh);
                    
                    resources.set(resourceInfo.id, {
                        mesh: mesh,
                        type: resourceInfo.resource_type
                    });
                }
            });
            
            // Remove depleted resources
            resources.forEach((resource, id) => {
                if (!currentResourceIds.has(id)) {
                    scene.remove(resource.mesh);
                    resources.delete(id);
                }
            });
            
            // Update resource counts in UI
            document.getElementById('resource-tree').textContent = resourceCounts.tree;
            document.getElementById('resource-rock').textContent = resourceCounts.rock;
            document.getElementById('resource-farm').textContent = resourceCounts.farm;
            document.getElementById('resource-iron').textContent = resourceCounts.iron;
        }
        
        // Animation loop
        let lastTime = Date.now();
        let frameCount = 0;
        let fps = 60;
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (!isPaused) {
                // Smooth agent movement with faster interpolation
                agents.forEach(agent => {
                    agent.mesh.position.lerp(agent.targetPos, 0.3); // Increased from 0.1 for snappier movement
                    
                    // Add subtle bobbing animation (breathing effect)
                    const time = Date.now() * 0.001;
                    agent.mesh.position.y += Math.sin(time * 2 + agent.mesh.position.x) * 0.005;
                    
                    // Faster rotation for more active appearance
                    agent.mesh.rotation.y += 0.02; // Doubled from 0.01
                });
                
                controls.update();
                renderer.render(scene, camera);
            }
            
            // Calculate FPS
            frameCount++;
            const currentTime = Date.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Mouse movement for tooltips
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const agentMeshes = Array.from(agents.values()).map(a => a.mesh);
            const intersects = raycaster.intersectObjects(agentMeshes, true);
            
            if (intersects.length > 0) {
                const hoveredMesh = intersects[0].object.parent || intersects[0].object;
                
                // Find which agent this mesh belongs to
                for (const [id, agent] of agents) {
                    if (agent.mesh === hoveredMesh) {
                        showTooltip(agent, event.clientX, event.clientY);
                        return;
                    }
                }
            }
            
            hideTooltip();
        }
        
        function onClick(event) {
            // Could add click interactions here
        }
        
        // Show tooltip for agent
        function showTooltip(agent, x, y) {
            const tooltip = document.getElementById('tooltip');
            const data = agent.agentData || {};
            
            tooltip.innerHTML = `
                <h4>${agent.name}</h4>
                <div class="tooltip-row">
                    <span class="tooltip-label">State:</span>
                    <span class="tooltip-value">${agent.state}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Faction:</span>
                    <span class="tooltip-value">${agent.faction ? '‚öîÔ∏è At War' : 'None'}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Position:</span>
                    <span class="tooltip-value">
                        ${agent.mesh.position.x.toFixed(1)}, 
                        ${agent.mesh.position.z.toFixed(1)}
                    </span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">ID:</span>
                    <span class="tooltip-value" style="font-size: 9px;">${data.id || 'Unknown'}</span>
                </div>
            `;
            
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.style.display = 'block';
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        // Log activity to feed
        function logActivity(message, type) {
            // Deduplicate - don't add if same message exists recently
            if (activityLog.length > 0 && activityLog[0].message === message) {
                return;
            }
            
            const timestamp = new Date().toLocaleTimeString();
            activityLog.unshift({ message, timestamp, type });
            
            // Keep only last 20 items
            if (activityLog.length > 20) {
                activityLog.pop();
            }
            
            // Update display
            const activityList = document.getElementById('activity-list');
            if (activityList) {
                activityList.innerHTML = activityLog.map(item => `
                    <div class="activity-item">
                        <div>${item.message}</div>
                        <div class="activity-time">${item.timestamp}</div>
                    </div>
                `).join('');
            }
        }
        
        // Global functions for UI
        window.resetCamera = function() {
            camera.position.set(70, 60, 70);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        };
        
        window.togglePause = function() {
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');
            btn.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
        };
        
        // Show notification toast
        function showNotification(title, body) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `
                <div class="notification-title">${title}</div>
                <div class="notification-body">${body}</div>
            `;
            document.body.appendChild(notification);
            
            // Remove after animation completes
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // Combat particle effect
        function createCombatEffect(position) {
            const particleCount = 20;
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xff6600,
                    transparent: true,
                    opacity: 1.0
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 2,
                    (Math.random() - 0.5) * 2
                );
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Animate particles
            let life = 0;
            const animateParticles = () => {
                life += 0.05;
                particles.children.forEach(p => {
                    p.position.add(p.velocity);
                    p.velocity.y -= 0.05; // Gravity
                    p.material.opacity = 1.0 - life;
                });
                
                if (life < 1.0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                }
            };
            animateParticles();
        }
        
        // Death explosion effect
        function createDeathEffect(position) {
            const particleCount = 30;
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.15, 4, 4);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x888888,
                    transparent: true,
                    opacity: 1.0
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    Math.random() * 3 + 1,
                    (Math.random() - 0.5) * 3
                );
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Animate explosion
            let life = 0;
            const animateExplosion = () => {
                life += 0.03;
                particles.children.forEach(p => {
                    p.position.add(p.velocity);
                    p.velocity.y -= 0.08; // Gravity
                    p.material.opacity = 1.0 - life;
                });
                
                if (life < 1.0) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(particles);
                }
            };
            animateExplosion();
        }
        
        // Start the visualizer
        init();
        
        console.log('üåç World Simulation Visualizer Started');
        console.log('API: ' + API_URL);
        console.log('State Colors:', STATE_COLORS);
    </script>
</body>
</html>

